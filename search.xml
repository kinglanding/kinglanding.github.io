<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[hexo yilia主题增加文章阅读数]]></title>
      <url>http://kinglanding.github.io/2016/06/30/2016-06-30-hexo-add-post-hits/</url>
      <content type="html"><![CDATA[<p>hexo是一个静态页面，诸如统计，留言之类的动态内容都需要依赖第三方服务，或者你自己有服务器资源也可以自己写个，
真心不难，对于文章阅读数统计，有几个第三方服务提供商：</p>
<ol>
<li>leancloud</li>
<li>firebase</li>
<li>busuanzi</li>
</ol>
<p>经过对比，个人任务leancloud最优，免费账号提供的资源足够用了;cdn在国内，对于国内用户方位速度较快;可以在归档页面显示
文章阅读数。就像这样
<img src="/img/post/post-archieve-hits.png" alt="文章浏览数 效果图"></p>
<p>下面结合网上众多的教程，写下在yilia主题下增加文章阅读数的过程。</p>
<a id="more"></a>
<h2>准备leancloud应用</h2>
<p>完成leancloud账户注册，然后新建应用：</p>
<p><img src="/img/post/leancloud-app.png" alt="新建应用"></p>
<p>然后新创建一个Class，起名就叫Counter吧，权限选择<code>无限制</code></p>
<p><img src="/img/post/create-app.png" alt="创建Class"></p>
<p>然后取得你的应用信息，待会会用。</p>
<p><img src="/img/post/getappkey.png" alt="getAppInfo"></p>
<h2>修改yilia主题</h2>
<p>在增改yilia主题文件文件之前，先改下主目录的配置文件<code>_config.yml</code></p>
<h3>修改<code>_config.yml</code>配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  app_id: your_app_id</span><br><span class="line">  app_key: your_app_key</span><br></pre></td></tr></table></figure>
<h3>增加Counter插件</h3>
<p>在主题的layout目录下新建立一个_widget目录，然后新建文件<code>Counter.ejs</code>,当然你可以按照你的意思在将这个代码放到
符合你意愿的文件中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jQuery文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 你可以用官方的cdn，那就把这里注释掉 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">js</span>('<span class="attr">js</span>/<span class="attr">av-core-mini-0.6.1</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">AV.initialize(<span class="string">"&lt;%= theme.leancloud_visitors.app_id %&gt;"</span>, <span class="string">"&lt;%= theme.leancloud_visitors.app_key%&gt;"</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意这里，一会要把这个js文件引入进来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">js</span>('<span class="attr">js</span>/<span class="attr">Counter</span>') %&gt;</span></span><br></pre></td></tr></table></figure>
<h3>新建Counter.js</h3>
<p>在主题（这里是yilia）的<code>source/js</code>目录下，新建<code>Counter.js</code>。内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是显示 归档等地方的 点击数的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params">Counter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(Counter);</span><br><span class="line">    $(<span class="string">".leancloud_visitors"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> url = $(<span class="keyword">this</span>).attr(<span class="string">"id"</span>).trim();</span><br><span class="line">        query.equalTo(<span class="string">"url"</span>, url);</span><br><span class="line">        query.find(&#123;</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (results.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> content = <span class="string">'0 '</span> + $(<span class="built_in">document</span>.getElementById(url)).text();</span><br><span class="line">                    $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> object = results[i];</span><br><span class="line">                    <span class="keyword">var</span> content = object.get(<span class="string">'time'</span>) + <span class="string">' '</span> + $(<span class="built_in">document</span>.getElementById(url)).text();</span><br><span class="line">                    $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">object, error</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Error: "</span> + error.code + <span class="string">" "</span> + error.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params">Counter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Counter = AV.Object.extend(<span class="string">"Counter"</span>);</span><br><span class="line">    <span class="comment">// 注意 选择子 选择的类名，如果你想自定义类名，别忘记修改这里</span></span><br><span class="line">    url = $(<span class="string">".leancloud_visitors"</span>).attr(<span class="string">'id'</span>).trim();</span><br><span class="line">    title = $(<span class="string">".leancloud_visitors"</span>).attr(<span class="string">'data-flag-title'</span>).trim();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(Counter);</span><br><span class="line">    query.equalTo(<span class="string">"url"</span>, url);</span><br><span class="line">    query.find(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(results);</span><br><span class="line">            <span class="comment">// 如果命中，浏览数+1</span></span><br><span class="line">            <span class="keyword">if</span> (results.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> counter = results[<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">console</span>.log(counter.get(<span class="string">'time'</span>));</span><br><span class="line">                counter.fetchWhenSave(<span class="literal">true</span>);</span><br><span class="line">                counter.increment(<span class="string">"time"</span>);</span><br><span class="line">                counter.save(<span class="literal">null</span>, &#123;</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">counter</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> content = counter.get(<span class="string">'time'</span>) + <span class="string">' '</span> + $(<span class="built_in">document</span>.getElementById(url)).text();</span><br><span class="line">                        $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 注意，这里如果请求leancloud，为了不至于显示不了数字，改成如下的代码</span></span><br><span class="line">                    error: <span class="function"><span class="keyword">function</span> (<span class="params">counter, error</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> content = counter.get(<span class="string">'time'</span>) + <span class="string">' '</span> + $(<span class="built_in">document</span>.getElementById(url)).text();</span><br><span class="line">                        $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line">                        <span class="comment">//console.log('Failed to save Visitor num, with error message: ' + error.message);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有命中，新建counter项</span></span><br><span class="line">                <span class="keyword">var</span> newcounter = <span class="keyword">new</span> Counter();</span><br><span class="line">                newcounter.set(<span class="string">"title"</span>, title);</span><br><span class="line">                newcounter.set(<span class="string">"url"</span>, url);</span><br><span class="line">                newcounter.set(<span class="string">"time"</span>, <span class="number">1</span>);</span><br><span class="line">                newcounter.save(<span class="literal">null</span>, &#123;</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">newcounter</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"newcounter.get('time')="</span> + newcounter.get(<span class="string">'time'</span>));</span><br><span class="line">                        <span class="keyword">var</span> content = newcounter.get(<span class="string">'time'</span>) + <span class="string">' '</span> + $(<span class="built_in">document</span>.getElementById(url)).text();</span><br><span class="line">                        $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: <span class="function"><span class="keyword">function</span> (<span class="params">newcounter, error</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Failed to create'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error:'</span> + error.code + <span class="string">" "</span> + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Counter = AV.Object.extend(<span class="string">"Counter"</span>);</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="string">'.leancloud_visitors'</span>).length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log($(<span class="string">'.leancloud_visitors'</span>));</span><br><span class="line">        addCount(Counter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($(<span class="string">'.post-title-link'</span>).length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意边界值</span></span><br><span class="line">        showTime(Counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3>修改head.ejs</h3>
<p>在head.ejs中的<code>&lt;/head&gt;</code>加上如下代码就好，以便能够加载到我们上面定义的<code>Counter.ejs</code>页面组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 增加点击次数插件--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.leancloud_visitors.enable</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">..</span>/<span class="attr">_widget</span>/<span class="attr">Counter</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3>修改post/tag.ejs</h3>
<p>这个看你个人意愿，想把点击数放到什么地方了，按照我的审美，我决定把他放在tag后面，如上面的效果图哈。</p>
<p>在文件中，append一下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.leancloud_visitors.enable</span>) &#123; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个counter-tag counter的样式，你们得自己弄啊.. 我就不想贴样式代码了.. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"counter-tag counter"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 别忘记这个类名... post-title-link --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;"</span> <span class="attr">class</span>=<span class="string">"leancloud_visitors post-title-link"</span></span><br><span class="line">          <span class="attr">style</span>=<span class="string">"font-size: 12px"</span> <span class="attr">data-flag-title</span>=<span class="string">"&lt;%= post.title %&gt;"</span>&gt;</span></span><br><span class="line">         &amp;nbsp;</span><br><span class="line">    <span class="comment">&lt;!-- 这里给出浏览数,定义在language中哈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">post.visitors</span>') %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<h3>修改语言配置文件</h3>
<p>给你喜欢的语言增加上下面的配置吧，我都写成这样了..</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post:</span><br><span class="line">  ...</span><br><span class="line">  visitors: Hits</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3>调整样式</h3>
<p>最后你得按照你的主题调整下样式吧~ 这个我花费的时间最长来，比如如何显示那个眼睛啊~ 什么是Font awesome..
写styl文件，定义counter-tag counter的样式，还是那句话，你可以自定义类名，自定义样式。</p>
<h3>折腾</h3>
<p>你肯定得琢磨个把小时，好好享受这个过程吧。</p>
<h2>部署应用</h2>
<p>到了这里你肯定做好了吧:&gt;,那么就把它托管到github上吧,有问题随时交流~~</p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="https://forum.leancloud.cn/t/yong-hu-fen-xiang-shi-yong-leancloud-wei-hexo-bo-ke-tian-jia-wen-zhang-liu-lan-liang-tong-ji-zu-jian/280" target="_blank" rel="external">使用 LeanCloud 为 Hexo 博客添加文章浏览量统计组件</a></li>
<li><a href="http://www.jeyzhang.com/hexo-next-add-post-views.html" target="_blank" rel="external">Hexo的NexT主题个性化：添加文章阅读量</a></li>
<li><a href="http://ibruce.info/2013/12/22/count-views-of-hexo/" target="_blank" rel="external">为hexo博客添加访问次数统计功能</a></li>
<li><a href="https://astronautweb.co/snippet/font-awesome/" target="_blank" rel="external">FontAwesome参考1</a></li>
<li><a href="http://www.bootcss.com/p/font-awesome/" target="_blank" rel="external">FontAwesome参考2</a></li>
<li><a href="http://fontawesome.io/icon/eye/" target="_blank" rel="external">使用FontAwesome fa-eye</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在idea中启用热加载]]></title>
      <url>http://kinglanding.github.io/2016/06/29/2016-6-29-hotload-in-idea/</url>
      <content type="html"><![CDATA[<p>idea真是开发神奇，越来越喜爱。修改个类或者资源文件啥的不在用重新部署下容器，
也不用像eclipse那样装上JRebel的插件，有点太重。只需要这样：</p>
<p><img src="/img/post/use-hotload.png" alt="use-hotload hotload"></p>
<p>如此，就好，注意On frame deactivation这个选项，实际就是当你离开当前的frame时，
idea就默默为你编译工程文件，然后放到explored的war中去了。本质就是将改好后的类
编译一下就好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java基础系列2：反射]]></title>
      <url>http://kinglanding.github.io/2016/06/23/java-base-seri-2-reflection/</url>
      <content type="html"><![CDATA[<p>反射功能强大，运用运行时获取任意类的任何属性和方法。功能虽强大，单不要滥用哦。反射的概念是由Smith在1982年首次提出的，
主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。
它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。当然反射本身并不是一个新概念，
它可能会使我们联想到光学中的反射概念，尽管计算机科学赋予了反射概念新的含义，但是，从现象上来说，它们确实有某些相通之处，这些有助于我们的理解。</p>
<h2>反射的应用场景</h2>
<p>反射通常用来在运行期检测和修改应用的行为，是一项相对高级的特性。</p>
<ul>
<li>可扩展<br>
　　应用可以使用外部或者用户自定义的类，来创建实例。</li>
<li>类浏览、IDE<br>
　　类浏览器需要读取类的成员。嘿，瞧瞧你现在使用的IDE，是不是有个地方可以浏览类的成员对象？这种类元信息可视化的功能就是借助于反射实现的。
各种开发工具就是凭借这个特性读取的类型信息，帮助开发及时发现错误。</li>
<li>调试、测试工具<br>
　　调试器需要获取类的私有成员。测试工具可以用来获取类的所有方法，从而编写对应的测试用例，保证覆盖到所有方法。</li>
</ul>
<p>通过上面的描述，是不是有了感性的认识？原来好多地方都使用到了反射，好厉害，我也要多多用用他们！且慢，往下看。</p>
<a id="more"></a>
<h2>反射的缺点</h2>
<p>尽管反射功能强大，但是不能肆意使用。如果可以不通过反射就能达到目的，最好就是避免使用它。在使用反射访问代码时，以下几点需要注意：</p>
<ul>
<li>性能开销<br>
　　因为反射涉及到动态类型解析，所以一些java优化指令不会被执行。因此，翻身操作比起一般操作来说，性能低多了。性能敏感类应用应该避免
在调用频繁的地方使用反射。</li>
<li>安全限制<br>
　　反射需要运行时权限。但是当运行在安全管理器下，这个权限有可能不存在。例如Applet类应用需要运行在严格的安全环境中，此时就必须好好考虑下如何
权衡反射和安全的问题了。</li>
<li>内部暴漏<br>
　　因为反射执行一些‘非法’操作，相对<em>非反射</em>而言,例如访问<em>private</em>成员（变量和方法），有可能会导致一些副作用，例如代码功能失调或者丧失移植性。</li>
</ul>
<h1>应用</h1>
<h2>Classes</h2>
<p>每个对象要不然是一引用类型，要不然就是基本类型。所有的引用类型都继承自<code>java.lang.Object</code>，类，枚举，队列和接口都是引用类型。而节本类型包含
<code>boolean</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>char</code>, <code>float</code>,和<code>double</code>。而引用类型，比如<code>String</code>、基本类型的包装类，接口<code>java.io.Serializable</code>,
以及枚举类型<code>SortOrder</code>。</p>
<p>对于每个类型，虚拟机都实例化了一个不可变的的<code>java.lang.Class</code>实例，可以在运行时提供方法，用于获取类型信息和成员。Class还可以创建新的类型和对象。
最重要的是，踏射所有反射API的入口。</p>
<h3>获取类对象</h3>
<p><code>java.lang.Class</code>提供了所有的反射操作方法。除了<code>java.lang.reflect.ReflectPermission</code>,所有<code>java.lang.reflect</code>包内的类都没有公共
构造函数。要想获取这些类，在<code>Class</code>中提供一些方法是必要的。提供了几种方式：1）使用对象；2）类名；3）现有的类。</p>
<h4>Object.getClass()</h4>
<p>最简单的方式就是调用<code>Object.getClass()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = <span class="string">"foo"</span>.getClass();</span><br></pre></td></tr></table></figure>
<p>返回结果是String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123; A, B &#125;</span><br><span class="line">Class c = A.getClass();</span><br></pre></td></tr></table></figure>
<p>因为A是枚举E的实例，返回值E</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">Class c = bytes.getClass();</span><br></pre></td></tr></table></figure>
<p>数组是Objects类型，当然可以调用<code>getClass()</code>，返回结果是数组类型和字节的组合<code>[B</code>.</p>
<h4>.class语法</h4>
<p>如果类型已知，但是对象并没有初始化，调用getClass方法会出错，此时可以使用.class的方式的得到类信息。我觉得这是最最简单的方式了。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b;</span><br><span class="line">Class c = b.getClass();   <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line">Class c = <span class="keyword">boolean</span>.class;  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>
<p>注意，boolean.getClass()是产生编译时错误，因为boolean是基本类型，是没有引用的。</p>
<h4>Class.forName()</h4>
<p>如果已知一个类的全名，可以使用类的静态方法<code>Class.forName()</code>.记住一点，这个不适用于基本类型。<code>Class.getName()</code>对引用类型和基本类型都适用。
例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cDoubleArray = Class.forName(<span class="string">"[D"</span>);</span><br><span class="line">Class cStringArray = Class.forName(<span class="string">"[[Ljava.lang.String;"</span>);</span><br></pre></td></tr></table></figure>
<h4>基本类型获取类型的方法</h4>
<p>使用.class可以很方便的获取基本类型的类型，除此之外，还可以使用<code>包装类.TYPE</code>的方式获取...
例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = Double.TYPE;</span><br><span class="line">Class c = Void.TYPE;</span><br></pre></td></tr></table></figure>
<p><code>Double.TYPE</code>等同于<code>double.class</code>.</p>
<h4>一些返回类型的方法</h4>
<p>有一些反射API可以返回类型</p>
<p><strong>Class.getSuperclass()</strong><br>
　　返回所给类的父类</p>
<p><strong>Class.getClasses()</strong><br>
　　返回类中所有<em>公共</em>的类，接口和枚举，包含继承类成员。当然也是public属性的。</p>
<p><strong>Class.getDeclaredClasses()</strong><br>
　　返回类中所有的类，接口，枚举。包括<em>private</em>修饰的类型</p>
<p><strong>Class.getDeclaringClass()<br>
java.lang.reflect.Field.getDeclaringClass()<br>
java.lang.reflect.Method.getDeclaringClass()<br>
java.lang.reflect.Constructor.getDeclaringClass()</strong><br>
　　返回声明这个类、域、方法或者构造函数的类。例如类ReflectTest中声明了一个B，那么B的声明类就是A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(B.class.getDeclaringClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据结果是class jls.basic.reflect.ReflectTest</p>
<p>匿名类声明不会有声明它的类，但是会拥有**包含（Enclosing）**它的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object anonymous  = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class claz = anonymous .getClass().getDeclaringClass();</span><br></pre></td></tr></table></figure>
<p>匿名类的声明类是null。</p>
<p><strong>Class.getEnclosingClass()</strong><br>
　　返回包含该类的类，例如上述例子中的B被ReflectTest包含。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object anonymous  = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class claz = anonymous .getClass().getEnclosingClass();</span><br></pre></td></tr></table></figure>
<p>匿名类此时的被包含类仍然是null...</p>
<h3>检查类的修饰符合类型</h3>
<p>类可以拥有一到多个修饰符，从而影响类的运行时行为。</p>
<ul>
<li>访问修饰符： public, protected 和 private</li>
<li>需要重载的修饰符： abstract</li>
<li>保证只有一个实例的修饰符： static</li>
<li>防止值修改的修饰符： final</li>
<li>强制执行IEEE 754浮点数标准修饰符： strictfp</li>
<li>注解</li>
</ul>
<p>注意，不是所有的修饰符，都可以修饰所有的类型，接口就不能使用<code>final</code>来修饰，枚举不能使用<code>abstract</code>修饰。<code>java.lang.reflect.Modifier</code>包含了各种
可能修饰符的声明。</p>
<p>下面样例介绍了如何获取一个类的各个声明部分：修饰符，泛型参数，接口和继承链。1.5版本的 Class实现了 <code>java.lang.reflect.AnnotatedElement</code>的接口。
所以也可以获取类的运行时注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.TypeVariable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDeclarationSpy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 获取类的全名</span></span><br><span class="line">            out.format(<span class="string">"Class:%n  %s%n%n"</span>, c.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取类的修饰符</span></span><br><span class="line">            out.format(<span class="string">"Modifiers:%n  %s%n%n"</span>,</span><br><span class="line">                    Modifier.toString(c.getModifiers()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取泛型参数 K V</span></span><br><span class="line">            out.format(<span class="string">"Type Parameters:%n"</span>);</span><br><span class="line">            TypeVariable[] tv = c.getTypeParameters();</span><br><span class="line">            <span class="keyword">if</span> (tv.length != <span class="number">0</span>) &#123;</span><br><span class="line">                out.format(<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">for</span> (TypeVariable t : tv)</span><br><span class="line">                    out.format(<span class="string">"%s "</span>, t.getName());</span><br><span class="line">                out.format(<span class="string">"%n%n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.format(<span class="string">"  -- No Type Parameters --%n%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取是实现的接口</span></span><br><span class="line">            out.format(<span class="string">"Implemented Interfaces:%n"</span>);</span><br><span class="line">            Type[] intfs = c.getGenericInterfaces();</span><br><span class="line">            <span class="keyword">if</span> (intfs.length != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Type intf : intfs)</span><br><span class="line">                    out.format(<span class="string">"  %s%n"</span>, intf.toString());</span><br><span class="line">                out.format(<span class="string">"%n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.format(<span class="string">"  -- No Implemented Interfaces --%n%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取继承链</span></span><br><span class="line">            out.format(<span class="string">"Inheritance Path:%n"</span>);</span><br><span class="line">            List&lt;Class&gt; l = <span class="keyword">new</span> ArrayList&lt;Class&gt;();</span><br><span class="line">            printAncestor(c, l);</span><br><span class="line">            <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; cl : l)</span><br><span class="line">                    out.format(<span class="string">"  %s%n"</span>, cl.getCanonicalName());</span><br><span class="line">                out.format(<span class="string">"%n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.format(<span class="string">"  -- No Super Classes --%n%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取注解</span></span><br><span class="line">            out.format(<span class="string">"Annotations:%n"</span>);</span><br><span class="line">            Annotation[] ann = c.getAnnotations();</span><br><span class="line">            <span class="keyword">if</span> (ann.length != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : ann)</span><br><span class="line">                    out.format(<span class="string">"  %s%n"</span>, a.toString());</span><br><span class="line">                out.format(<span class="string">"%n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.format(<span class="string">"  -- No Annotations --%n%n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// production code should handle this exception more gracefully</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAncestor</span><span class="params">(Class&lt;?&gt; c, List&lt;Class&gt; l)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; ancestor = c.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l.add(ancestor);</span><br><span class="line">            printAncestor(ancestor, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这么使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap</span><br><span class="line">输出：</span><br><span class="line">Class:</span><br><span class="line">  java.util.concurrent.ConcurrentNavigableMap</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public abstract interface</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  K V</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  java.util.concurrent.ConcurrentMap&lt;K, V&gt;</span><br><span class="line">  java.util.NavigableMap&lt;K, V&gt;</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  -- No Super Classes --</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  -- No Annotations --</span><br></pre></td></tr></table></figure>
<p>还可以这么使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ava ClassDeclarationSpy "[Ljava.lang.String;"</span><br><span class="line">Class:</span><br><span class="line">  java.lang.String[]</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public abstract final</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  -- No Type Parameters --</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  interface java.lang.Cloneable</span><br><span class="line">  interface java.io.Serializable</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  java.lang.Object</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  -- No Annotations --</span><br></pre></td></tr></table></figure>
<p><code>[Ljava.lang.String;</code>代表String[], 因为String类的修饰符就是final，并且实现了Cloneable和Serializable接口，而且数据类型是继承自Object。
解析是正确的。</p>
<p>注意哈，不是所有的注解都会被探测到的，只有那些Retention是RUNTIME的注解才会被加载到虚拟机中，所以一些预定义的注解如<code>@Override</code>，<code>@Deprecated</code>和
<code>@SuppressWarnings</code>,只有<code>@Deprecated</code>可以在运行时获取。</p>
<h3>发现类成员</h3>
<p><code>Class</code>类提供了两类方法，用于获取fields，methods和constructors：一类是列举这些成员；一类是通过名字搜索成员。一些方法可以直接获取类本身声明的
成员，相对应的是，一些方法可以搜索父接口和父类的继承成员。下表是<code>成员定位方法</code>的一些特性总结。</p>
<p><code>Class</code>类中<code>域定位</code>方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>List of members?</th>
<th>Inherited members?</th>
<th>Private members?</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredField(name)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>getField(name)</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>getFields()</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><code>Class</code>类中<code>方法定位</code>方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>List of members?</th>
<th>Inherited members?</th>
<th>Private members?</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>getMethod(String name,Class&lt;?&gt;... parameterTypes)</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>getMethods()</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><code>Class</code>类中<code>构造函数定位</code>方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>List of members?</th>
<th>Inherited members?</th>
<th>Private members?</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</td>
<td>no</td>
<td>N/A</td>
<td>yes</td>
</tr>
<tr>
<td>getConstructor(Class&lt;?&gt;... parameterTypes)</td>
<td>no</td>
<td>N/A</td>
<td>no</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>yes</td>
<td>N/A</td>
<td>yes</td>
</tr>
<tr>
<td>getConstructors()</td>
<td>yes</td>
<td>N/A</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>注意，构造函数是不会继承的。</p>
<p>下面这个ClassSpy函数，是一个使用get*s()方法获取所有public和继承的元素的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Member;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ClassMember &#123;CONSTRUCTOR, FIELD, METHOD, CLASS, ALL&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassSpy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] rag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接在这里修改就可以了。</span></span><br><span class="line">        String[] args = &#123;<span class="string">"jls.basic.reflect.ClassSpy"</span>,<span class="string">"ALL"</span>&#125;; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            out.format(<span class="string">"Class:%n  %s%n%n"</span>, c.getCanonicalName());</span><br><span class="line"></span><br><span class="line">            Package p = c.getPackage();</span><br><span class="line">            out.format(<span class="string">"Package:%n  %s%n%n"</span>,</span><br><span class="line">                    (p != <span class="keyword">null</span> ? p.getName() : <span class="string">"-- No Package --"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (ClassMember.valueOf(args[i])) &#123;</span><br><span class="line">                    <span class="keyword">case</span> CONSTRUCTOR:</span><br><span class="line">                        printMembers(c.getConstructors(), <span class="string">"Constructor"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> FIELD:</span><br><span class="line">                        printMembers(c.getFields(), <span class="string">"Fields"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> METHOD:</span><br><span class="line">                        printMembers(c.getMethods(), <span class="string">"Methods"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CLASS:</span><br><span class="line">                        printClasses(c);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ALL:</span><br><span class="line">                        printMembers(c.getConstructors(), <span class="string">"Constuctors"</span>);</span><br><span class="line">                        printMembers(c.getFields(), <span class="string">"Fields"</span>);</span><br><span class="line">                        printMembers(c.getMethods(), <span class="string">"Methods"</span>);</span><br><span class="line">                        printClasses(c);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// production code should handle these exceptions more gracefully</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMembers</span><span class="params">(Member[] mbrs, String s)</span> </span>&#123;</span><br><span class="line">        out.format(<span class="string">"%s:%n"</span>, s);</span><br><span class="line">        <span class="keyword">for</span> (Member mbr : mbrs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbr <span class="keyword">instanceof</span> Field)</span><br><span class="line">                out.format(<span class="string">"  %s%n"</span>, ((Field) mbr).toGenericString());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbr <span class="keyword">instanceof</span> Constructor)</span><br><span class="line">                out.format(<span class="string">"  %s%n"</span>, ((Constructor) mbr).toGenericString());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbr <span class="keyword">instanceof</span> Method)</span><br><span class="line">                out.format(<span class="string">"  %s%n"</span>, ((Method) mbr).toGenericString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mbrs.length == <span class="number">0</span>)</span><br><span class="line">            out.format(<span class="string">"  -- No %s --%n"</span>, s);</span><br><span class="line">        out.format(<span class="string">"%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClasses</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        out.format(<span class="string">"Classes:%n"</span>);</span><br><span class="line">        Class&lt;?&gt;[] clss = c.getClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; cls : clss)</span><br><span class="line">            out.format(<span class="string">"  %s%n"</span>, cls.getCanonicalName());</span><br><span class="line">        <span class="keyword">if</span> (clss.length == <span class="number">0</span>)</span><br><span class="line">            out.format(<span class="string">"  -- No member interfaces, classes, or enums --%n"</span>);</span><br><span class="line">        out.format(<span class="string">"%n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子很简单，注意Field，Method，Constructor都实现了Member接口，函数printMembers在根据具体类型进行强制类型转换，打印。</p>
<p>使用也很简单，直接运行，就好。运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class:</span><br><span class="line">  jls.basic.reflect.ClassSpy</span><br><span class="line"></span><br><span class="line">Package:</span><br><span class="line">  jls.basic.reflect</span><br><span class="line"></span><br><span class="line">Constuctors:</span><br><span class="line">  public jls.basic.reflect.ClassSpy()</span><br><span class="line"></span><br><span class="line">Fields:</span><br><span class="line">  -- No Fields --</span><br><span class="line"></span><br><span class="line">Methods:</span><br><span class="line">  public static void jls.basic.reflect.ClassSpy.main(java.lang.String[])</span><br><span class="line">  public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">  public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">  public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">  public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">  public java.lang.String java.lang.Object.toString()</span><br><span class="line">  public native int java.lang.Object.hashCode()</span><br><span class="line">  public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass()</span><br><span class="line">  public final native void java.lang.Object.notify()</span><br><span class="line">  public final native void java.lang.Object.notifyAll()</span><br><span class="line"></span><br><span class="line">Classes:</span><br><span class="line">  -- No member interfaces, classes, or enums --</span><br></pre></td></tr></table></figure>
<h3>成员</h3>
<p>反射定义了<code>Member</code>接口，<code>Feild</code>,<code>Method</code>和<code>Constructor</code>都实现了该接口。下面分别讲述下每类成员的使用方法。
注意java语言规范，java SE 7 版本规定了，一个类的成员包括field，method，嵌套类，接口和枚举类型，已经继承自父类的
这类成员。因为构造函数是不能被继承的，他们不属于成员。这和Member接口的实现类（有Constructor）迥然不同..</p>
<h4>域</h4>
<p>域都有类型和值，<code>java.lang.reflect.Field</code>类提供了获取类型信息和值的get和set方法。</p>
<h5>获取字段类型</h5>
<p>域可能是基本类型，也可能是引用类型。基本类型包括8类：boolean，byte，short，int，long，char，float和double。引用类型就
直接或间接继承Object类型的类和接口，数组以及枚举类型。</p>
<p>下面这个程序可以打印类的字段信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldSpy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[][] b = &#123;&#123;<span class="keyword">false</span>, <span class="keyword">false</span>&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">true</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> T val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// class name</span></span><br><span class="line">            String[] args = &#123;<span class="string">"jls.basic.reflect.FieldSpy"</span>, <span class="string">"b"</span>&#125;;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Field[] fields = c.getFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                System.out.format(<span class="string">"Name: %s%n"</span>, field.getName());</span><br><span class="line">                System.out.format(<span class="string">"Type: %s%n"</span>, field.getType());</span><br><span class="line">                System.out.format(<span class="string">"GenericType: %s%n"</span>, field.getGenericType());</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// production code should handle these exceptions more gracefully</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Name: b</span><br><span class="line">Type: class [[Z</span><br><span class="line">GenericType: class [[Z</span><br><span class="line"></span><br><span class="line">Name: name</span><br><span class="line">Type: class java.lang.String</span><br><span class="line">GenericType: class java.lang.String</span><br><span class="line"></span><br><span class="line">Name: list</span><br><span class="line">Type: interface java.util.List</span><br><span class="line">GenericType: java.util.List&lt;java.lang.Integer&gt;</span><br><span class="line"></span><br><span class="line">Name: val</span><br><span class="line">Type: class java.lang.Object</span><br><span class="line">GenericType: T</span><br></pre></td></tr></table></figure>
<p>Field.getType()返回的是Class&lt;?&gt;类型，需要注意的是，val的类型是Object，这是因为泛型在编译期经过类型擦除之后，所有的信息都不见了。所以T的类型就被顶层类型替换掉了，也就是成了Object类型。</p>
<p>Field.getGenericType返回的是Type类型，这个函数将会查询class文件中的签名属性，如果不能获取该属性，那么它就会调用Field.getType().</p>
<h4>获取域的修饰符</h4>
<h4>设置域的值</h4>
<p>程序写起来很简单，不在列举了。只是有个地方需要注意下：通过反射设置域的值会带来一定的性能损耗，因为会涉及一些权限验证等操作。所以使用反射会使运行时的优化下降。
例如如下的代码很有可能被java虚拟机优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">2</span>;</span><br><span class="line">x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用Field.set*(),那么优化就不会发生了，每行都会执行一遍。。</p>
<h3>方法</h3>
<p>方法都拥有返回值，形参和异常。Method类提供了获取形参和返回值的类型信息方法。也可以调用给定对象的方法。</p>
<ul>
<li>获取方法的类型信息</li>
<li>获取方法形参的名字</li>
<li>获取解析方法修饰符</li>
<li>方法调用</li>
</ul>
<p>反射提供了一种方法调用的方式，一般很少使用，除非强制类型转化不起作用，才有必要使用这种方式。结合jdk中的源码和下面的例子，会有更好的感性认识。
直接看代码和注释就好，可以直接运行这个代码增加感性认识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 私有函数，不可能被访问。使用反射修改修饰符，然后在调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无形参</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有形参，有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String sentence = <span class="string">"Hello "</span> + name;</span><br><span class="line">        <span class="keyword">return</span> sentence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载本类</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">"jls.basic.reflect.MethodInvoker"</span>);</span><br><span class="line">            <span class="comment">// 实例化1个本类的对象</span></span><br><span class="line">            Object t = c.newInstance();</span><br><span class="line">            <span class="comment">// getDeclaredMethod 用来获取私有函数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用helloWorld 这个私有方法,所以方法名是helloWorld</span></span><br><span class="line">            String privateMethodName = <span class="string">"helloWorld"</span>;</span><br><span class="line">            <span class="comment">// 因为helloWorld 的无形参，所以构造一个大小为零的数组</span></span><br><span class="line">            Class[] helloWorldMethodParameterTypes = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 获取私有函数</span></span><br><span class="line">            Method helloWorldMethod = c.getDeclaredMethod(privateMethodName, helloWorldMethodParameterTypes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用私有方法... 不用设置访问属性..</span></span><br><span class="line">            <span class="comment">//helloWorldMethod.setAccessible(true);</span></span><br><span class="line">            out.format(<span class="string">"invoking %s()%n"</span>, helloWorldMethod.getName());</span><br><span class="line">            Object result = helloWorldMethod.invoke(t, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 返回值是null</span></span><br><span class="line">            out.format(<span class="string">"%s() returned: %s%n"</span>, helloWorldMethod.getName(), result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 hello 这个私有方法,所以方法名是helloWorld</span></span><br><span class="line">            privateMethodName = <span class="string">"hello"</span>;</span><br><span class="line">            <span class="comment">// hello 方法有一个String类型的参数，所以构造一个大小为1的数组</span></span><br><span class="line">            Class[] helloMethodParameterTypes = <span class="keyword">new</span> Class[]&#123;String.class&#125;;</span><br><span class="line">            String parameter = <span class="string">"aluen"</span>;</span><br><span class="line">            <span class="comment">// 获取私有函数</span></span><br><span class="line">            Method helloMethod = c.getDeclaredMethod(privateMethodName, helloMethodParameterTypes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用私有方法</span></span><br><span class="line">            <span class="comment">//helloMethod.setAccessible(true);</span></span><br><span class="line">            out.format(<span class="string">"invoking %s()%n"</span>, helloMethod.getName());</span><br><span class="line">            result = helloMethod.invoke(t, parameter);</span><br><span class="line">            <span class="comment">// 返回值是String</span></span><br><span class="line">            out.format(<span class="string">"%s() returned: %s%n"</span>, helloMethod.getName(), result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// production code should handle these exceptions more gracefully</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException x) &#123;</span><br><span class="line">            x.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>构造函数</h3>
<h4>构造类的实例</h4>
<p>创建实例有两类方法，<code>java.lang.reflect.Constructor.newInstance()</code>和<code>Class.newInstance()</code>.前者用的更多，因为：</p>
<ul>
<li><code>Class.newInstance()</code>只能调用无参构造函数，而<code>Constructor.newInstance()</code>可以调用任意构造函数。</li>
<li><code>Class.newInstance()</code>会抛出构造函数所有的异常；而<code>Constructor.newInstance()</code>可以将这些异常打包成<code>InvocationTargetException</code>.</li>
<li><code>Class.newInstance()</code></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dive into annotation]]></title>
      <url>http://kinglanding.github.io/2016/06/22/dive-into-annotation/</url>
      <content type="html"><![CDATA[<p>初识注解，还是源自懵懂年代查看开源代码中的<code>@Override</code>,<code>@Deprecated</code>,<code>@SuppressWarnings</code>,这种新特性引进与jdk5.0, 借助于编辑器的功劳，
能为平常的代码编写提供很多的帮助。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Override</td>
<td>表明当前方法是覆盖了父类方法，好的编程习惯，编译器会检查代码的某些错误</td>
</tr>
<tr>
<td>Deprecated</td>
<td>表明当前的元素已经不推荐使用</td>
</tr>
<tr>
<td>SuppressWarnings</td>
<td>关闭不当的编译器警告信息</td>
</tr>
</tbody>
</table>
<h1>自定义注解</h1>
<p>在编写自定义注解之前，有必要了解下<code>java.lang.annotation</code>这个包</p>
<a id="more"></a>
<h2>元注解(meta-annotation)</h2>
<p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解,
UML图如下所示:</p>
<p><img src="/img/post/dive-into-annotation.png" alt="java.lang.annotation UML图"></p>
<p>其中最为重要的就是红色框内的类。包含4个元注解，2个枚举类。</p>
<ul>
<li>Retention</li>
<li>Documented</li>
<li>Target</li>
<li>Inherited</li>
</ul>
<p>以上4个注解即为jdk提供的元注解，因为他们的Target的适应类型都是<code>ElementType.ANNOTATION_TYPE</code>,只能用于修饰其他注解。</p>
<table>
<thead>
<tr>
<th>元注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retention</td>
<td>描述注解的生命周期，详见RetentionPoicy解释</td>
</tr>
<tr>
<td>Documented</td>
<td>若一个注解A使用@Document修饰，那么被A修饰的类Class，可以使用javadoc编译Class，A将会显示</td>
</tr>
<tr>
<td>Target</td>
<td>用于描述注解的使用范围</td>
</tr>
<tr>
<td>Inherited</td>
<td>若一个注解A使用@Inherited修饰，那么被A修饰的类Parent的子类Child会继承注解A的修饰</td>
</tr>
</tbody>
</table>
<p>另外两个枚举类是<code>ElementType</code>和<code>RetentionPolicy</code>,见如下表格:</p>
<table>
<thead>
<tr>
<th>ElementType</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>TYPE</td>
<td>描述类、接口(包括注解类型)或enum声明</td>
</tr>
<tr>
<td>FIELD</td>
<td>域声明（包含枚举常量）</td>
</tr>
<tr>
<td>METHOD</td>
<td>方法声明</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>参数声明</td>
</tr>
<tr>
<td>CONSTRUCTOR</td>
<td>构造函数声明</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>局部变量声明</td>
</tr>
<tr>
<td>ANNOTATION_TYPE</td>
<td>注解类型声明，和TYPE相比，这个类型只能用于注解！（元注解的Target都是这个声明）</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>包声明</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>ElementType</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOURCE</td>
<td>被该字段修饰的注解，会被编译器丢弃</td>
</tr>
<tr>
<td>CLASS</td>
<td>编译器会将该注解记录到class文件中，不会被加载到虚拟机中，这是Target的默认值</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>编译器会将该注解记录到class文件中，也会被加载到虚拟机中。所以有可能会通过反射读取。</td>
</tr>
</tbody>
</table>
<h2>如何编写自定义的注解</h2>
<p>定义注解，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@meta</span>-annotation A</span><br><span class="line"><span class="meta">@meta</span>-annotation B</span><br><span class="line"><span class="meta">@meta</span>-annotation ...</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName &#123;</span><br><span class="line">    <span class="comment">// 方法实际上是声明了一个配置参数, 方法的名称就是参数的名称</span></span><br><span class="line">    <span class="comment">// 可以通过default来声明参数的默认值。(option)</span></span><br><span class="line">    <span class="keyword">public</span> TYPE function-name() [ <span class="keyword">default</span> &#123;vlaue&#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@meta-annotation A</code>是一些元注解；
@interface自定义注解，自动继承了java.lang.annotation.Annotation接口，由编译器完成内部细节。
<code>TYPE</code>是返回值类型，只能是基本类型，Class，String，enum和Annotation以及他们的数据类型。
方法名即参数名，使用时类型这样 <code>@AnnotationName(function-name = {value})</code></p>
<h2>例子</h2>
<p>Doc注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用Documented （meta-annotation 元注释），用来</span><br><span class="line"> * 生成javadoc</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Doc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Document注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用Documented （meta-annotation 元注释），用来</span><br><span class="line"> * 生成javadoc,这个保留到运行期</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Document &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Color注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Color &#123;</span><br><span class="line">    <span class="function">ColorPolicy <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ColorPolicy.RED</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Name注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Name &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColorPolicy 枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation.use;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ColorPolicy &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLACK,</span><br><span class="line">    PUPLE,</span><br><span class="line">    YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例，用来说明如何使用注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jls.basic.annotation.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jls.basic.annotation.Doc;</span><br><span class="line"><span class="keyword">import</span> jls.basic.annotation.Document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Doc</span><span class="comment">// 这是一个SOURCE级别的注解</span></span><br><span class="line"><span class="meta">@Document</span>(<span class="string">"Document是RUNTIME级的"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Name</span>(value = <span class="string">"banana"</span>)</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="meta">@Color</span>(value = ColorPolicy.BLACK)</span><br><span class="line">    <span class="keyword">protected</span> ColorPolicy color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Banana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ColorPolicy <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(ColorPolicy color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Banana&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", color="</span> + color +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">        System.out.println(banana);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 要想使用注解，还是得自己动手丰衣足食啊~</span></span><br><span class="line">        </span><br><span class="line">        Class clz = Banana.class;</span><br><span class="line">        <span class="comment">// 看是否有Doc类型的注解。无，因为Doc注解的Retention是SOURCE</span></span><br><span class="line">        System.out.println(clz.getAnnotation(Doc.class));</span><br><span class="line">        <span class="comment">// 看是否有 Document 类型的注解。有，因为Document注解的Retention是 RUNTIME</span></span><br><span class="line">        System.out.println(clz.getAnnotation(Document.class));</span><br><span class="line">        <span class="comment">// 获取class level的注解值</span></span><br><span class="line">        Document document = (Document) clz.getAnnotation(Document.class);</span><br><span class="line">        System.out.println(document.value());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 类 这一level上的所有注解</span></span><br><span class="line">        Annotation[] annotations = clz.getDeclaredAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析字段，像Spring初始化bean的方式那样设置字段的值</span></span><br><span class="line">        Field[] fields = clz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Color.class)) &#123;</span><br><span class="line">                banana.setColor(field.getAnnotation(Color.class).value());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.isAnnotationPresent(Name.class)) &#123;</span><br><span class="line">                banana.setName(field.getAnnotation(Name.class).value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(banana);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Banana</code>使用注解修饰了name和color，是不是给人一种感觉:&quot;只要我初始化一个对象，它就应该有默认值啦~&quot;，上述例子main函数的前两行说明这个现象，new了一个对象，
打印下，诶？ 怎么没有值？注解并不像在无参构造函数中给某些字段赋初值。注解如果没有额外的操作，是不起作用的。</p>
<p>所以有了下面的那些操作，通过反射获取注解，拿到他们的值，在给对象设置值，ok，其实这就是Spring底层初始化bean的逻辑，通过bean工厂类，拿到bean中的注解值，
返回一个有值的对象，托管到Spring容器中.</p>
<p>所以呢，注解要和反射结合起来，才能起作用。后面再总结啦。</p>
<h2>总结</h2>
<p>有个思维导图不错，侵权立删
<img src="http://images.cnitblog.com/blog/34483/201304/25200814-475cf2f3a8d24e0bb3b4c442a4b44734.jpg" alt="注解思维导图"></p>
<blockquote>
<p>Reference</p>
</blockquote>
<ol>
<li><a href="http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html" target="_blank" rel="external">图片来源</a></li>
<li><a href="http://blog.csdn.net/duo2005duo/article/details/50505884" target="_blank" rel="external">Java注解（1）-基础</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSR-133 FAQ]]></title>
      <url>http://kinglanding.github.io/2016/05/16/2016-05-16-JSR-133-FAQ/</url>
      <content type="html"><![CDATA[<h1>内存模型究竟是个啥玩意儿？</h1>
<p>在多处理器的架构中，处理器一般拥有一到几层缓存，缓存是个好东西，它既可以用来提供获取数据的速度（缓存嘛~离处理器更近！），又可以减少
竞争共享内存总线的次数（因为很多内存数据的操作可以在缓存中完事儿~）。缓存可以惊人地提高性能，但同时也引入的新的挑战。如：</p>
<ol>
<li>如果两个处理器同时访问同一块内存区域，应该如何处理？</li>
<li>在什么条件下，保证他们看到同样的值？</li>
</ol>
<p>内存模型定义了在处理器层面上的重要条件：1. 其他处理器的写操作对当前处理可见；2. 当前处理的写操作对其他处理器可见。一些处理器（exhibit）
定义了<strong>强内存模型</strong>: 任何时间，任意处理器访问统一内存区域，读取的值都是一样的。还有一些处理器exhibit）实现了<em>若内存模型</em>：这种内存模型定义
了一种特殊指定，叫做<strong>内存屏障(memory barriers)</strong>, 这种指令会将本处理器缓存中数据清除或者置为无效，以此保证其他处理器的写操作对其可见；或者
本身的写操作对其他处理器可见。内存屏障一般随加锁，释放锁的操作一起执行。对高级语言来说，他们是不见的。</p>
<a id="more"></a>
<p>编写强内存模型的程序有时会更简单一些，因为减少了内存屏障这类指令的使用。但是，即使对于一些最强的内存模型，内存屏障也是必要的：他们所处的位置也是违反
直觉的。最新的处理器设计趋势是故事使用若内存模型，在多核处理和更大的内存量上，缓存一致性的松弛会带来更高的扩展性。</p>
<p>写操作对另外的线程何时可见取决于编译器对代码的重排序：例如，如果编译器或许会决定将一个写操作滞后会提高程序性能，只要代码移动不会改变程序的语义，当然可以
这么做。如果编译器延迟一个操作，另外一个线程只有在操作执行滞后才会看到：这反映了缓存的效果。</p>
<p>另外，写内存的操作也可以提前：这样场景下，其它线程很可能会在写操作实际<strong>发生前</strong>就看到它(例如volatile的内存语义)。这种灵活性都是提前设计好的。将这种灵活的操作
给与编译器，运行时，和硬件，形成代码的最有执行顺序，在内存模型的约束下，我们可以达到更高的性能。</p>
<p>参考以下简单的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r1 = y;</span><br><span class="line">    <span class="keyword">int</span> r2 = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设现在有两个线程并行执行,并且读取y的值是2.因为y的写操作在x之后，你可能会认为x的值一定是1。但是，由于写操作有可能会重排序。如果这样，有可能代码的重排序
结果是这样的。先写y的值，然后在读取y和x，最后在写x。这种场景下r1的值就是2，r2的值就是0.</p>
<p>java内存模型了描述了并发场景下的合法行为，线程是如何和内存交互的。它描述了从内存、寄存器中存取变量的底层细节。这种模型可以使用各种硬件和各种各样的编译器优化正确的实现。</p>
<p>java包含一些语言关键字，比如<strong>volatile</strong>,<strong>final</strong>,和<strong>synchronized</strong>,这些关键词帮助程序员编写并发程序。JMM定义了volatile和synchronized的行为，最重要的是
，保证了正确的同步程序可以无误的跑在所有的处理器架构上。</p>
<h1>其他语言，比如C++，有内存模型吗？</h1>
<p>大多数程序编程语言，比如C和C++，并没有直接对多线程编程提供支持。所以这类语言的重排序的保证严重依赖于编译器和架构的保证，例如线程库，所使用的编译器，和目标运行平台。</p>
<h1>JSR 133描述了什么</h1>
<p>从1997以来，原有的JMM发现了几个缺陷，这些瑕疵会导致令人困惑的行为（常量字段的值被观测到变化了），破坏编译器执行通用优化点能力。</p>
<p>Java Memory Model是一个雄心勃勃的进击：首次提出了编程规范，用可提供一致性语义的内存模型解决跨平台并发问题。不幸的是，定义一个一致性并且符合直觉的内存模型
被证明比预想的难。JSR 133模型定义了一个新的内存模型，修复了早期内存模型的缺陷。为了达到这一目的，<strong>final</strong>和<strong>volatile</strong>的语义需要做下改变。</p>
<p>JSR 133的目标:</p>
<ol>
<li>保存现有的安全保证，例如类型安全。加强其它方面。比如，变量值不能凭空产生：每个线程读到的变量值必须是某个线程合理赋值的。</li>
<li>正确的同步程序语义必须尽简洁明了直观。</li>
<li>不正确的同步程序语义应该制定清楚，最小化潜在的安全危害</li>
<li>程序员可以自信地解释出多线程程序时如何和内存交互的</li>
<li>尽可能在广大流行架构上设计跨平台、正确、高性能的JVM实现</li>
<li><strong>安全初始化</strong>保证。如果一个对象被正确的构建（意味着对象构建期间，引用不会提前溢出或者对外发布），所有引用这个对象的线程都可以看到对象的final字段的值（在构建函数中
设置的值），并且不需要同步。</li>
<li>对现有代码影响最小化。</li>
</ol>
<h1>重排序意味什么</h1>
<p>有许多诸如访问变量的场景（对象的字段，类静态字段、数组元素），会按照看起来和代码写的顺序不一样的操作顺序执行。编译器会以最优化的名义自由重排序指令。
处理器可能会乱序执行指令。数据在集群器、缓存及内存中的移动顺序有可能和程序中指定的不一样。</p>
<p>比如，一个线程给a赋值，再给b赋值，并且a和b的操作无依赖，那么，编译器可以自由重排序这些操作。缓存可以把b写到内存中。编译器，JIT，缓存中都会做出重排序的操作。</p>
<p>编译器，运行时和影响可以协力创建看起来像串行执行的假象，对于一个单线程来说，重排序对他来说没有任何影响。但是重排序有可能导致多线程的执行结果异常。一个
线程观察到其他线程的影响；或者在正常的语义中，一些线程本不应该提前访问某个变量的值。</p>
<p>大多数时间，线程不需要关系其他线程做什么操作。但是有些时候，例如共享内存的场景，那么就需要进行同步操作了。</p>
<h1>旧的内存模型存在的问题</h1>
<p>之前旧的内存模型存在几个严重的问题。例如，不支持重排序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Latex on hexo]]></title>
      <url>http://kinglanding.github.io/2016/04/27/testlatex/</url>
      <content type="html"><![CDATA[<p>\begin{aligned}
\phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
= \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j)
\end{aligned}</p>
<p>$$\frac{\partial u}{\partial t}
= h^2 \left( \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} +
\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<span>$$\begin{aligned}
\dot{x} &amp; = \sigma(y-x) \\
\dot{y} &amp; = \rho x - y - xz \\
\dot{z} &amp; = -\beta z + xy
\end{aligned}$$</span><!-- Has MathJax -->
<p>\begin{aligned}
\dot{x} &amp; = \sigma(y-x) \
\dot{y} &amp; = \rho x - y - xz \
\dot{z} &amp; = -\beta z + xy
\end{aligned}</p>
<p>Simple inline $a = b + c$.</p>
<span>$$f(x1, x2) = \frac{ 1 }{2\pi \sigma1\sigma2\sqrt{1-r^2}}e^{-\frac{1}{2(1-r^2)} 
[\frac{(x1-\mu\_{x1})^2}{\sigma\_{x1}^2} - \frac{2r(x1-\mu\_{x1})(x2-\mu\_{x2})}{\sigma\_{x1} \sigma\_{x2}} + \frac{(x2-\mu\_{x2})^2}{\sigma\_{x2}^2}]}$$</span><!-- Has MathJax -->
<span>$$\begin{aligned}
  &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \\
      \vdots &amp; \ddots &amp; \vdots \\
      \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{aligned}$$</span><!-- Has MathJax -->
<span>$$\min { \quad \frac { 1 }{ 2 } \left\| w \right\| ^{ 2 }+c\sum _{ i=1 }^{ l }{ { \xi }_{ i } } } \\ st.\quad y_{ i }(\omega ^{ T }\phi (x_i)-b)\ge 1-\xi _{ i },\left( \xi _{ i }&gt;0 \right)$$</span><!-- Has MathJax -->  ]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于异常在线程与线程池不同表现的一个思考]]></title>
      <url>http://kinglanding.github.io/2016/04/27/2016-04-27-think-about-difference-of-exception-between-thread-and-pool/</url>
      <content type="html"><![CDATA[<p>如果一个线程在执行的过程中，遇到了某种异常，中断异常啊、空指针异常啊、算数异常，并且程序本身没有捕获异常，会发送什么？你可能会说，程序直接挂掉呗~然后日志里有异常日志。</p>
<p>但实际上，要看这个线程是在什么地方。如果是在线程池外面，这个程序确实就直接挂掉了；</p>
<a id="more"></a> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testThreadFeatures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testThreadFeatures</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] ast = <span class="keyword">null</span>;</span><br><span class="line">            String str = <span class="keyword">new</span> String(ast);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ： can you see me :&gt;...."</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">    thread.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果，毫无意外的显示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line"> 	at java.lang.String.&lt;init&gt;(String.java:168)</span><br><span class="line"> 	at thread.ThreadRunAndHang$1.run(ThreadRunAndHang.java:51)</span><br><span class="line"> 	at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"> 	at thread.ThreadRunAndHang.testThreadFeatures(ThreadRunAndHang.java:58)</span><br><span class="line"> 	at thread.ThreadRunAndHang.main(ThreadRunAndHang.java:42)</span><br><span class="line"> 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line"> 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line"> 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line"> 	at java.lang.reflect.Method.invoke(Method.java:606)</span><br><span class="line"> 	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)</span><br></pre></td></tr></table></figure>
<p>如果是在线程池中呢？线程池怎么捕捉线程出现的异常？例如 一个线程因为某个RuntimeException导致线程挂了。如何处理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testThreadPoolFeatures</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">       <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(), </span><br><span class="line">       <span class="keyword">new</span> DefaultThreadFactory());</span><br><span class="line"></span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" ： hello i am running...."</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" : now i begin to make something different...."</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">char</span>[] ast = <span class="keyword">null</span>;</span><br><span class="line">               String str = <span class="keyword">new</span> String(ast);</span><br><span class="line"></span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" ： can you see me :&gt;...."</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">"thread1"</span>); <span class="comment">// 这里给线程命名其实是不管用的哈！因为有ThreadFactory，那里面对线程重新命名了=。=</span></span><br><span class="line">       </span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" ： hello i am running...."</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" ： now i begin to make something different...."</span>);</span><br><span class="line"></span><br><span class="line">               System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                   <span class="string">" ： can you see me :&gt;...."</span>);</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                   ;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">"thread2"</span>);</span><br><span class="line">       service.submit(thread);</span><br><span class="line">       service.submit(thread2);</span><br><span class="line">       System.out.println(<span class="string">"running...."</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>结果显示,但是程序本身并没有终止运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> running....</span><br><span class="line"><span class="built_in">test</span>-1-thread-2 ： hello i am running....</span><br><span class="line"><span class="built_in">test</span>-1-thread-1 ： hello i am running....</span><br><span class="line"><span class="built_in">test</span>-1-thread-2 ： now i begin to make something different....</span><br><span class="line"><span class="built_in">test</span>-1-thread-2 ： can you see me :&gt;....</span><br><span class="line"><span class="built_in">test</span>-1-thread-1 : now i begin to make something different....</span><br></pre></td></tr></table></figure>
<p>感兴趣的话可以查看下程序栈，会发现线程test-1-thread-1是处于WAITING状态的！尝试从queue队列中取新的任务。所以是WAITING状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test-1-thread-2"</span> prio=6 tid=0x000000000c42b800 nid=0x2e9c waiting on condition [0x000000000d10f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000007d6088290&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:489)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:678)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:615)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"test-1-thread-1"</span> prio=6 tid=0x000000000c42b000 nid=0x3a0 waiting on condition [0x000000000cf2f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000007d6088290&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:489)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:678)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:615)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>
<p>看接口Runnable的定义，及其简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object's</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是定义成这样，就意味着我们没有办法在run()方法的实现中抛出异常，啊哈哈，没有办法抛出Checked异常啦。要处理checked exception，简单的一个try/catch块就可以了。但是万一程序里不小心抛出一个RuntimeException，又该咋办捏？</p>
<p>还是看Thread源码，已经规定了这么一个玩意儿，<code>UncaughtExceptionHandler</code>这个接口的实现可以用来处理那些线程未捕获的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Method invoked when the given thread terminates due to the</span><br><span class="line">         * given uncaught exception.</span><br><span class="line">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span><br><span class="line">         * Java Virtual Machine.</span><br><span class="line">         * <span class="doctag">@param</span> t the thread</span><br><span class="line">         * <span class="doctag">@param</span> e the exception</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null unless explicitly set</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null unless explicitly set</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure>
<p>但是默认这类handler是没有设置的（<code>null unless explicitly set</code>）！这好办！自个儿写个UncaughtExceptionHandler接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Thread.UncaughtExceptionHandler exceptionHandler = <span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">"有麻烦了，详情是："</span> + e.toString());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"线程的状态是："</span> + t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.setDefaultUncaughtExceptionHandler(exceptionHandler);</span><br></pre></td></tr></table></figure>
<p>这么一来，运行结果就是这样啦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main有麻烦了，详情是：java.lang.NullPointerException</span><br><span class="line">[Ljava.lang.StackTraceElement;@<span class="number">14</span>c4b664</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">	at java.lang.String.&lt;init&gt;(String.java:<span class="number">168</span>)</span><br><span class="line">	at thread.ThreadRunAndHang$<span class="number">1</span>.run(ThreadRunAndHang.java:<span class="number">51</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">744</span>)</span><br><span class="line">	at thread.ThreadRunAndHang.testThreadFeatures(ThreadRunAndHang.java:<span class="number">66</span>)</span><br><span class="line">	at thread.ThreadRunAndHang.main(ThreadRunAndHang.java:<span class="number">42</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">140</span>)</span><br></pre></td></tr></table></figure>
<p>这部分的输出正好就是UncaughtExceptionHandler接口的实现。对于unchecked exception，可以采用类似事件注册的机制做一定程度的处理。程序也不会崩溃啦~~</p>
<h4>阶段性总结</h4>
<p>Java thread里面关于异常的部分比较奇特。接口的定义意味着不能直接在一个线程中抛出异常。一般在线程里碰到checked exception，标准的做法是采用try/catch块来处理。而对于unchecked exception，比较合理的方式是注册一个实现 UncaughtExceptionHandler 接口的对象实例来处理。</p>
<p>在回到线程池的问题中...</p>
<p>为啥线程池没有打印处理这些UncaughtException呢？(低声:因为你没有set线程池中线程的 UncaughtExceptionHandler 啊...)=。=好吧！在DefaultThreadFactory的newThread方法中加上线程的UncaughtExceptionHandler嘛~。运行，一脸黑线，TMD的什么鬼，还是木有！！！</p>
<p>翻看了下 ThreadPoolExecutor 的代码，找到了这个关键点！！！看 runWorker 这个方法的注释哈！原文描述的第4点和第5点很重要~ 不贴代码了，可以看下<code>jdk1.7.0_51#ThreadPoolExecutor#runWorker#1081~1165</code></p>
<blockquote>
<p>假设 <code>beforeExecute</code> 运行没问题， 就开始执行<code>task</code>了，注意是调用 <code>task.ran</code> 当做普通方法调用的！！然后收集任何抛出的异常，扔给 <code>afterExecute （默认是空实现哈，所以异常没有被处理）</code>因为 <code>Runnable.run</code> 方法不能抛出 Throwables ，所以就打包扔了出去，其实是扔给线程的 UncaughtExceptionHandler 了。保险起见，任何抛出的异常都会导致线程挂掉。执行完 task.run 方法之后，就开始调用 <code>afterExecute</code> 了。 这个方法也可能会抛出异常，此时同样会导致线程挂掉。</p>
</blockquote>
<p>这个时候又看了下 <code>afterExecute</code> 的注释，重载或者重写该方法就好了，咱们直接这么用就好啦~ ExecutorService 对象的创建方法变一变，覆盖原来的方法.接下来就是见证奇迹的时刻~~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> DefaultThreadFactory())</span><br><span class="line">        <span class="comment">// 覆盖ThreadPoolExecutor中的afterExecute方法！</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"有麻烦了，详情是："</span> + t.toString());</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行一下,见证下奇迹,你妹的,千呼万唤始出来啊</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test-1-thread-2 ： hello i am running....</span><br><span class="line">test-1-thread-1 ： hello i am running....</span><br><span class="line">test-1-thread-2 ： now i begin to make something different....</span><br><span class="line">test-1-thread-2 ： can you see me :&gt;....</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">	at thread.ThreadRunAndHang$3.afterExecute(ThreadRunAndHang.java:82)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1153)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:744)</span><br><span class="line">test-1-thread-1 : now i begin to make something different....</span><br><span class="line">Thread-2</span><br><span class="line">test-1-thread-1有麻烦了，详情是：java.lang.NullPointerException</span><br><span class="line">线程的状态是：RUNNABLE</span><br></pre></td></tr></table></figure>
<h4>阶段性总结</h4>
<p>线程池如果想要处理unchecked exception :</p>
<ol>
<li>要重新实现线程工厂的newThread方法，需要为线上加上 UncaughtExceptionHandler。</li>
<li>实现  UncaughtExceptionHandler 接口，定义个性化的需求。</li>
<li>覆盖ThreadPoolExecutor.afterExecute 方法。
以上，就能捕获线程池中线程的异常了。</li>
</ol>
<blockquote>
<p>Reference</p>
</blockquote>
<ol>
<li>http://www.blogjava.net/xylz/archive/2013/08/05/402405.html</li>
<li>http://stackoverflow.com/questions/1838923/why-is-uncaughtexceptionhandler-not-called-by-executorservice</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用mongodb内置的mapreduce聚合函数统计词频]]></title>
      <url>http://kinglanding.github.io/2015/01/14/2015-01-15-use-mongo-map-reduce-statistic-word-occurrence/</url>
      <content type="html"><![CDATA[<p>有个需求需要对数据库中的某个字段进行频率统计，数据量较大，大概在2亿左右。</p>
<p>在之前先用一个简单的例子描述下问题。</p>
<p>比如我有一个mongo中的文档集合，比如说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; summary:&quot;This is good&quot; &#125;,</span><br><span class="line">    &#123; summary:&quot;This is bad&quot; &#125;,</span><br><span class="line">    &#123; summary:&quot;Something that is neither good nor bad&quot; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&gt;db.test.insert(&#123; summary:&quot;This is good&quot; &#125;);</span><br><span class="line">&gt;db.test.insert(&#123; summary:&quot;This is bad&quot; &#125;;</span><br><span class="line">&gt;db.test.insert(&#123; summary:&quot;Something that is neither good nor bad&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>现在要统计每个单词的出现次数，忽略大小写，最后按照升序排序，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;is&quot;: 3,</span><br><span class="line">    &quot;bad&quot;: 2,</span><br><span class="line">    &quot;good&quot;: 2,</span><br><span class="line">    &quot;this&quot;: 2,</span><br><span class="line">    &quot;neither&quot;: 1,</span><br><span class="line">    &quot;nor&quot;: 1,</span><br><span class="line">    &quot;something&quot;: 1,</span><br><span class="line">    &quot;that&quot;: 1</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>所以我们可以使用mongo中自带的聚合函数框架——mapreduce，然后我们自己根据需求
写个map函数和reduce函数就可以了。</p>
<a id="more"></a>
<p>关于<a href="http://docs.mongodb.org/manual/core/map-reduce/" target="_blank" rel="external">Map-Reduce</a>可以看到更加
详细的介绍，尤其适用于服务器端的文档处理率操作。</p>
<p>然后看是map函数，每个doc会传给这个<code>map</code>函数，这个这个函数会查找<code>summary</code>这个字段，若存在，则变小写，根据空格分割字符串，每个字置为1.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> summary = <span class="keyword">this</span>.summary;</span><br><span class="line">    <span class="keyword">if</span> (summary) &#123; </span><br><span class="line">        <span class="comment">// quick lowercase to normalize per your requirements</span></span><br><span class="line">        summary = summary.toLowerCase().split(<span class="string">" "</span>); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = summary.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// might want to remove punctuation, etc. here</span></span><br><span class="line">            <span class="keyword">if</span> (summary[i])  &#123;      <span class="comment">// make sure there's something</span></span><br><span class="line">               emit(summary[i], <span class="number">1</span>); <span class="comment">// store a 1 for each word</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在写<code>reduce</code>函数，它是把<code>map</code>函数得到的结果加起来，并最终返回每个字的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span>(<span class="params"> key, values </span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;    </span><br><span class="line">    values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;            </span><br><span class="line">        count +=v;    </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后命令行执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.test.mapReduce(map, reduce, &#123;out: <span class="string">"word_count"</span>&#125;)</span><br><span class="line">&gt;db.word_count.find().sort(&#123;value：-1&#125;)</span><br></pre></td></tr></table></figure>
<p>即可看到结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : &quot;is&quot;, &quot;value&quot; : 3 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;bad&quot;, &quot;value&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;good&quot;, &quot;value&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;this&quot;, &quot;value&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;neither&quot;, &quot;value&quot; : 1 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;or&quot;, &quot;value&quot; : 1 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;something&quot;, &quot;value&quot; : 1 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;that&quot;, &quot;value&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>
<h3>统计重复字段</h3>
<p>比如说要统计<code>taobao_id</code>这个字段，其他字段在这里用<code>summary</code>代指，这里面有的doc没有<code>taobao_id</code>字段，有的为空，这种情况会随软件版本升级出现类似情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;summary&quot; : &quot;this is good&quot;, &quot;taobao_id&quot; : &quot;ad23x@#sa&quot; &#125;</span><br><span class="line">&#123; &quot;summary&quot; : &quot;this is bad&quot;, &quot;taobao_id&quot; : &quot;ad23x@#sa&quot; &#125;</span><br><span class="line">&#123; &quot;summary&quot; : &quot;this is holy shit!&quot;, &quot;taobao_id&quot; : &quot;ad23x@#2323sa&quot; &#125;</span><br><span class="line">&#123; &quot;summary&quot; : &quot;you are so fucking clever&quot;, &quot;taobao_id&quot; : &quot;ad123x@#2323sa&quot; &#125;</span><br><span class="line">&#123; &quot;summary&quot; : &quot;you r idiot&quot;, &quot;taobao_id&quot; : &quot;&quot; &#125;</span><br><span class="line">&#123; &quot;summary&quot; : &quot;it is deliciouse&quot; &#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>函数如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> taobao_id = <span class="keyword">this</span>.taobao_id;</span><br><span class="line">    <span class="comment">// make sure there is the field.</span></span><br><span class="line">    <span class="keyword">if</span>(taobao_id)</span><br><span class="line">    	<span class="comment">// store a 1 for this taobao_id</span></span><br><span class="line">        emit(taobao_id,<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>reduce</code>函数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span>(<span class="params">key,values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        count+=v;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.so.mapReduce(map,reduce,&#123;out:<span class="string">"taobao_id_count"</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"result"</span> : <span class="string">"taobao_id_count"</span>,</span><br><span class="line">	<span class="string">"timeMillis"</span> : 58,</span><br><span class="line">	<span class="string">"counts"</span> : &#123;</span><br><span class="line">		<span class="string">"input"</span> : 6,</span><br><span class="line">		<span class="string">"emit"</span> : 4,</span><br><span class="line">		<span class="string">"reduce"</span> : 1,</span><br><span class="line">		<span class="string">"output"</span> : 3</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"ok"</span> : 1,</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.taobao_id_count.<span class="function"><span class="title">find</span></span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"ad123x@#2323sa"</span>, <span class="string">"value"</span> : 1 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"ad23x@#2323sa"</span>, <span class="string">"value"</span> : 1 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"ad23x@#sa"</span>, <span class="string">"value"</span> : 2 &#125;</span><br></pre></td></tr></table></figure>
<p>在服务器上运行得到
如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;result&quot; : &quot;taobao_id_count&quot;,</span><br><span class="line">   &quot;counts&quot; : &#123;</span><br><span class="line">       &quot;input&quot; : NumberLong(166299476),</span><br><span class="line">       &quot;emit&quot; : NumberLong(98911196),</span><br><span class="line">       &quot;reduce&quot; : NumberLong(2492253),</span><br><span class="line">       &quot;output&quot; : NumberLong(95269211)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>字段说明：
总共存在有1.6亿个doc（其实这个数还是不准，多谢俊德指出db.device.count()的个数为227186295）；</p>
<p>其中存在taobao_id的doc数为98911196个；</p>
<p>总共规约的个数（即taobao_id重复的个数大于1的）为2492253个；</p>
<p>最后的结果有95269211个。</p>
<p>没有taobao_id的doc数大约为7千万。</p>
<p>重复的taobao_id个数为使用如下命令得出，大约花费1分钟
db.taobao_id_count.count({&quot;value&quot;:{$gt:1}})
2234285</p>
<p>结果验证：
db.taobao_id_count.find({&quot;value&quot;:2})
得到一堆在重复个数为2的taobao_id集合。
在重复个数为2的taobao_id中，用它的taobao_id在device总集中查找，看返回结果是否为两个。db.device.find({&quot;taobao_id&quot;:&quot;+/quUacD9KYQAAcmQQglxvvO&quot;})
结果只有两个结果</p>
<blockquote>
<p>Referrence</p>
</blockquote>
<ol>
<li>
<p><a href="http://docs.mongodb.org/manual/tutorial/write-scripts-for-the-mongo-shell/" target="_blank" rel="external">write scripts for the mongo shell</a></p>
</li>
<li>
<p><a href="http://jackyrong.iteye.com/blog/1408548" target="_blank" rel="external">快速例子学习mongodb的mapreduce</a></p>
</li>
<li>
<p><a href="http://stackoverflow.com/questions/16174591/mongo-count-the-number-of-word-occurences-in-a-set-of-documents" target="_blank" rel="external">词频统计</a></p>
</li>
<li>
<p><a href="http://docs.mongodb.org/manual/core/map-reduce/" target="_blank" rel="external">map reduce</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈微博标签聚合]]></title>
      <url>http://kinglanding.github.io/2014/09/02/2014-09-02-qian-tan-wei-bo-biao-qian-ju-he/</url>
      <content type="html"><![CDATA[<p>标注问题在机器学习中是一个监督学习的问题，当然在这里我们所要面对是微博中用户给自己添加标签的
问题，并不是研究如何给用户添加标签。
浏览微博中用户的个人资料时，你会发现大部分用户都给自己添加了自认为所属类别的标签，这个很正确，
属于人工标注的典例。但是，细细浏览下每个人的标签我们会发现，其实好多标签的意思是一样的，比如
<code>苹果</code>，<code>iphone</code>，<code>iphone5</code>，的意思是类似的，还有<code>安卓</code>,<code>Android</code>,<code>智能手机</code>，<code>安卓手机</code>,
很明显，他们又是类，有没有办法把类似的标签聚集在一起呢？</p>
<p>直到现在，从我们的需求出发可以看到这是一个聚类问题，将相似的标签聚集到一起，并找出可以代表这
类相似标签的标签。</p>
<p>整体思路是根据用户的标签数据集得到“标签-用户”矩阵，考录到这个矩阵大部分为0值，所以使用稀疏矩阵
来降低内存无用消耗。然后使用一个相似度来代表距离，可以使用cosine相似度，pearson相似度，等等，
在这里使用的是余弦相似度，使用这里的算法进行聚类之后，得到聚类模型，如图所示。</p>
<p>接下来就是找到相似的标签，这个我们可以想象，从根节点开始，离根节点越远的拥有共同祖先的叶节点相似
越大，每个内节点都有一个代表它孩子的相似度，我们需要做的是，找到一个cutoff，然后，只要某个节点
小于该cutoff，那么认为他们之前没有相似关系，若大于改值，则意味这以改节点为祖先的叶节点是一个
簇，简单实用，而且效果不错。</p>
<p>到现在为止，我们找到了相似的标签集合，那么如何从集合中找到代表性的标签呢？一个显而易见的就是，计算
该标签被用户引用的次数，简单的总是最好的！</p>
<p>如图所示，这是按照上述思路完成的结果的一部分显示结果，数据太多，不方便显示。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[use svm to classify whether a person is good or bad on credit using sns data]]></title>
      <url>http://kinglanding.github.io/2014/07/12/2014-07-12-use-svm-to-classify-whether-a-person-is-good-or-bad-on-credit-using-sns-data/</url>
      <content type="html"><![CDATA[<p>首先说明这只是一个思路方向性的大概说明介绍，更多关于业务方面的内容不方便介绍。</p>
<p>如何评价一个人的金融信用，这个可以搜集用户的一些基本数据，比如职业，大学，社交数据来进行评分判断，至于为什么选取这些特征，一个很显然的理由就是
一个人越倾向使用社交应用，那么这个人就越可能是真实的，可信的。职业学校和人的信用也是成一定关系但不是绝对就是向我们想当然的那样。</p>
<p>之前的文章也断断续续的聊过伪匹配，分类的内容，是和此有一定关联。</p>
<p>对于模型的构建，方式有很多，贝叶斯网络，逻辑回归模型，svm模型，甚至是神经网络模型都可以对此进行建模使用，但是哪个性能更好呢？不知道，只有分别做出之后
比较才可以说明问题。</p>
<a id="more"></a>
<h4>非线性SVM</h4>
<p>前面的blog有讲到线性svm，对于非线性分类器就要把x映射到特征空间,同时考虑误差ε的存在（即有些样本点会越过分类边界），上述优化问题变为：</p>
<span>$\min { \quad \frac { 1 }{ 2 } \left\| w \right\| ^{ 2 }+c\sum _{ i=1 }^{ l }{ { \xi  }_{ i } }  } \\ st.\quad y_{ i }(\omega ^{ T }\phi (x_i)-b)\ge 1-\xi _{ i },\left( \xi _{ i }&gt;0 \right)$</span><!-- Has MathJax -->
<p>从输入空间是映射到特征空间的函数称为核函数，LibSVM中使用的默认核函数是RBF（径向基函数radial basis function），即</p>
<span>$K(x,y)=exp{ \left( \frac { -\left\| x-y \right\| ^{ 2 } }{ 2\sigma ^{ 2 } }  \right)  }$</span><!-- Has MathJax -->
<p>这样一来就有两个参数需要用户指定：c和gamma。实际上在LibSVM中用户需要给出一个c和gamma的区间，
LibSVM采用交叉验证cross-validation accuracy的方法确定分类效果最好的c和gamma。</p>
<p>举个例子说明什么是交叉验证，假如把训练样本集拆成三组，然后先拿 1 跟 2 来 train model 并 predict 3 以得到正确率；
再来拿 2 跟 3 train 并 predict 1 ，最后 1,3 train 并 predict 2 ，最后取预测精度最高的那组c和gamma。</p>
<h4>libsvm</h4>
<p>点击<a href="http://www.csie.ntu.edu.tw/~cjlin/cgi-bin/libsvm.cgi?+http://www.csie.ntu.edu.tw/~cjlin/libsvm+tar.gz" target="_blank" rel="external">here</a>下载libsvm.</p>
<p>看readme即可使用了。</p>
<p>LibSVM要求处理的文件数据都满足如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rlabel1 index1:value1   index2:value2   …...</span><br><span class="line">rlabel2 index1:value1   index2:value2   …...</span><br></pre></td></tr></table></figure>
<p>rlabel表示分类，为一个数字。Index从1开始递增，表示输入向量的序号，value是输入向量相应维度上的值，如果value为0,该项可以不写。下面是一个示例文件：</p>
<p>目前简单的分类所使用的属性有：年龄WOE   类型WOE   信用卡邮箱授权WOE  搜多引擎返回数WOE  贴吧搜索返回数WOE  微博数WOE  活跃度WOE  淘友朋友WOE 人人看过的人数WOE  好友数WOE  微博注册时间WOE
预测值为还款情况（还款1，逾期0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1:0.010003 2:-0.10524 3:0.131117521 4:0.061095504 5:0.029130009 6:-0.178635093 7:-0.149465309 8:-0.03275873 9:-0.047039163 10:-0.047039163 11:-0.158328769</span><br><span class="line">0 1:0.010003 2:-0.10524 3:0.131117521 4:-0.025995297 5:-0.051360537 6:-0.090148625 7:-0.149465309 8:-0.005168969 9:0.000132475 10:-0.050262447 11:-0.158328769</span><br><span class="line">0 1:-0.08606 2:-0.10524 3:0.131117521 4:-0.163782716 5:-0.051360537 6:-0.178635093 7:-0.149465309 8:-0.03275873 9:-0.047039163 10:-0.047039163 11:-0.158328769</span><br><span class="line">0 1:-0.21088 2:0.009167 3:0.131117521 4:0.061095504 5:0.029130009 6:-0.090148625 7:-0.129577755 8:-0.03275873 9:0.000132475 10:-0.050262447 11:-0.226676962</span><br></pre></td></tr></table></figure>
<p>svm_scale用于把输入向量按列进行规范化（或曰缩放）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: svm-scale [options] data_filename</span><br><span class="line">options:</span><br><span class="line"><span class="_">-l</span> lower : x scaling lower <span class="built_in">limit</span> (default -1)</span><br><span class="line">-u upper : x scaling upper <span class="built_in">limit</span> (default +1)</span><br><span class="line">-y y_lower y_upper : y scaling limits (default: no y scaling)</span><br><span class="line"><span class="_">-s</span> save_filename : save scaling parameters to save_filename</span><br><span class="line">-r restore_filename : restore scaling parameters from restore_filename</span><br></pre></td></tr></table></figure>
<p>例如： <code>svm_scale -l 0 -u 1 -s range trainSet &gt; trainSet.scale</code>则输入文件是trainSet，输出文件是trainSet.scale，把输入向量的各列都缩放到[0，1]的范围内，range文件中保存了相关的缩放信息。</p>
<p>这个时候我们应该把训练集分为两部分，训练集和测试集，在训练集上通过交叉验证学到最佳的参数，然后在测试集上验证。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$python</span> subset.py</span><br><span class="line">Usage: subset.py [options] dataset number [output1] [output2]</span><br><span class="line">This script selects a subset of the given data set.</span><br><span class="line">options:</span><br><span class="line"><span class="_">-s</span> method : method of selection (default 0)</span><br><span class="line"></span><br><span class="line">     0 -- stratified selection (classification only)</span><br><span class="line"></span><br><span class="line">     1 -- random selection</span><br><span class="line"></span><br><span class="line">output1 : the subset (optional)</span><br><span class="line"></span><br><span class="line">output2 : the rest of data (optional)</span><br><span class="line"></span><br><span class="line">If output1 is omitted, the subset will be printed on the screen.</span><br><span class="line"></span><br><span class="line"><span class="variable">$python</span> subset.py trainSet 0.3*m(实例个数) trainSet.data <span class="built_in">test</span>Set.data</span><br><span class="line">$ ./tools/subset.py ./trainningset.txt 280 <span class="built_in">test</span>Set trainSet</span><br></pre></td></tr></table></figure>
<p>grid.py是一种用于RBF核函数的C-SVM分类的参数选择程序。用户只需给定参数的一个范围，grid.py采用交叉验证的方法计算每种参数组合的准确度来找到最好的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python grid.py</span><br><span class="line">Usage: grid.py [-log2c begin,end,step] [-log2g begin,end,step] [-v fold]</span><br><span class="line">       [-svmtrain pathname] [-gnuplot pathname] [-out pathname] [-png pathname]</span><br><span class="line">       [additional parameters <span class="keyword">for</span> svm-train] dataset</span><br><span class="line">The program conducts v-fold cross validation using parameter C (<span class="keyword">and</span> gamma)= <span class="number">2</span>^begin, <span class="number">2</span>^(begin+step), ..., <span class="number">2</span>^end.</span><br></pre></td></tr></table></figure>
<p>首先<code>sudo apt-get install gnuplot</code></p>
<p>然后编译C++版本的LibSVM，生成svm-train二进制可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python grid.py -log2c -5,5,1 -log2g -4,0,1 -v 5 -svmtrain /path/to/your/svm-train -m 500 trainSet.data (svm-train 的路径自个找好)</span><br></pre></td></tr></table></figure>
<p>-m 500是使用svm_train时可以使用的参数。
最后输出两个文件：dataset.png绘出了交叉验证精度的轮廓图，dataset.out对于每一组log2(c)和log2(gamma)对应的CV精度值。</p>
<p>得到c=16，g=1</p>
<p>这个是我实验的截图</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/mlclass/master/libsvm-3.18/trainSet.png" alt="实验截图"></p>
<p>最后来训练我们的模型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./svm_train</span><br><span class="line"></span><br><span class="line"><span class="_">-s</span> svm_<span class="built_in">type</span> : <span class="built_in">set</span> <span class="built_in">type</span> of SVM (default 0)</span><br><span class="line">0 -- C-SVC</span><br><span class="line">-t kernel_<span class="built_in">type</span> : <span class="built_in">set</span> <span class="built_in">type</span> of kernel <span class="keyword">function</span> (default 2)</span><br><span class="line">0 -- linear: u<span class="string">'*v</span><br><span class="line">2 -- radial basis function: exp(-gamma*|u-v|^2)</span><br><span class="line">-g gamma : set gamma in kernel function (default 1/num_features) num_features是输入向量的个数</span><br><span class="line">-c cost : set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)</span><br><span class="line">-m cachesize : set cache memory size in MB (default 100) 使用多少内存</span><br><span class="line">-e epsilon : set tolerance of termination criterion (default 0.001) </span><br><span class="line">-h shrinking : whether to use the shrinking heuristics, 0 or 1 (default 1) </span><br><span class="line">-wi weight : set the parameter C of class i to weight*C, for C-SVC (default 1) 当各类数量不均衡时为每个类分别指定C</span><br><span class="line">-v n: n-fold cross validation mode交叉验证时分为多少组</span><br><span class="line">-q : quiet mode (no outputs)</span><br><span class="line"></span><br><span class="line">$ svm_train -s 0 -c 16 -t 2 -g 1 -e 0.01 trainSet.scale</span><br><span class="line">$ ./svm-train -s 2 -c 16 -g 1 -v 5 ./trainSet</span></span><br></pre></td></tr></table></figure>
<p>会得到训练结果，然后使用这个模型来预测测试集的数据准确性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./svm-predict <span class="built_in">test</span>Set result</span><br><span class="line">./svm-predict -b 0 <span class="built_in">test</span>Set trainSet.model  result</span><br></pre></td></tr></table></figure>
<h3>实验结果</h3>
<p>对数据进行格式转换后，首先对数据集进行分割得到训练集和测试集，选择常规比例为6：4</p>
<p>1.一开始未设置最有参数时即C和simga的值时，由训练集得到的模型分类性能在测试集上达到了Accuracy = 79.64285714285714% (223/280)的精度。</p>
<p>2.选择合适的参数。</p>
<p>通过交叉验证方法对模型进行选择得到针对训练集上最优的参数为c=16 g=1</p>
<p>由此得到的训练模型在测试集上的准确率达到了Accuracy = 81.4286% (228/280) (classification)，将近2%的精度提升，也算不错了。</p>
<p>目前由这些属性判断用户的还款情况，准确率在80%左右。但是预测结果全部预测为1.不合理。</p>
<p>实验结果准确率，在指定one-vs-class 之后，准确率为40%。比起逻辑回归模型仍然好点。</p>
<blockquote>
<blockquote>
<p>Ref</p>
</blockquote>
</blockquote>
<p>数据可以到<a href="https://github.com/aluenkinglee/mlclass/tree/master/libsvm-3.18" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[伪匹配]]></title>
      <url>http://kinglanding.github.io/2014/07/09/2014-07-09-wei-pi-pei/</url>
      <content type="html"><![CDATA[<p>这里提到的伪匹配的概念是指在网上搜索某些特征词，比如人名公司手机QQ号等内容时，网页反馈的结果：重要关键词在人看来是逻辑没有关联的时候就是伪匹配。</p>
<p>比如说，某XX，公司名，地点很明显的构成一个记录的时候，在人看来是个写在一起的，那么结果就是匹配的。相反，要是搜索词相距很远，那么就是伪匹配。</p>
<p>那么好，人工审核此类内容是否匹配时，是个无聊枯燥的工作内容，那么只好找机器帮忙，思路也很简单，分析样本伪匹配的原因是什么？和网页文档有什么不同？</p>
<p>对目标网页的分析可以发现，搜索词在目标网页中有时是结构化存在的，就是搜索词处在不同的节点中，节点关系为树中的关系，或者是兄弟关系，或者是父子关系。
同时还有非结构化的内容，比如搜索词是在同一个节点中，此时就不存在上述判断关系，只能由另外一种关系来处理。</p>
<a id="more"></a>
<p>接着说，当是结构化的关系的时候，从我们人的观点来看，他们应该是兄弟节点，相邻很近，或者用另外一个距离：节点到最近祖先再到另外一个节点的距离。此距离也是很近的。</p>
<p>当时非结构话的关系时，他们是在用一语意范围内，所以字符距离很近。</p>
<p>OK，有了上面的思路，我们所做的就是分析统计目标网页的结构，然后查看具体指标的范围。</p>
<p>首先看如何区分是否结构化，这个可以依靠text的长度来判断（这是分析后发现的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x1=[54,161,70,65,66,3369,101,50,167];</span><br><span class="line">y1=[1,1,1,1,1,1,1,1,1];</span><br><span class="line">x2=[114265,89406,137824,11300,14001,54575,108596,78197,67810,11948,8660,2677,103724,8686];</span><br><span class="line">y2=[0 0 0 0 0 0 0 0 0 0 0 0 0 0];</span><br><span class="line">figure ;</span><br><span class="line">plot(x1,y1,&apos;rx&apos;,&apos;MarkerSize&apos;,10);</span><br><span class="line">hold on;</span><br><span class="line">plot(x2,y2,&apos;bo&apos;,&apos;MarkerSize&apos;,10);</span><br></pre></td></tr></table></figure>
<p>数据是分析后得到的。</p>
<p>分布图如下：</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match1.png" alt="是否结构化与最长文本长度分布图" title="是否结构化与最长文本长度分布图"></p>
<p>从图形分界出来看，max(x1)=3369,min(x2)=2677,这个cutoff可以选取2677～3369之间的长度即可。</p>
<p>代码如下,摘选了函数的一部分，url是函数的形参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Document doc = Jsoup.connect(url).get();</span><br><span class="line">    Vector&lt;HashMap&lt;String, Integer&gt;&gt; map = <span class="keyword">new</span> Vector&lt;HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; tagCount = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; lenCount = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    Elements content = doc.getAllElements();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    String tag = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Element e : content) &#123;<span class="comment">// 此处就是遍历了</span></span><br><span class="line">        <span class="keyword">if</span> (e.ownText().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String key = e.nodeName();</span><br><span class="line">            <span class="keyword">int</span> len = e.ownText().length();</span><br><span class="line">            HashMap&lt;String, Integer&gt; ins = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            ins.put(key, len);</span><br><span class="line">            map.add(ins);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                max = len;</span><br><span class="line">                tag = key;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lenCount.containsKey(len)) &#123;</span><br><span class="line">                lenCount.put(len, lenCount.get(len) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lenCount.put(len, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tagCount.containsKey(key)) &#123;</span><br><span class="line">                tagCount.put(key, tagCount.get(key) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tagCount.put(key, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    System.out.println(tagCount);</span><br><span class="line">    System.out.println(lenCount);</span><br><span class="line">    System.out.println(tag + <span class="string">":"</span> + max);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    <span class="comment">// e.printStackTrace();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在做搜索节点的距离值的分布，一个搜索词可以会出现在不同的位置，既然搜索词之间有关联效应，那么，即使出现位置很多，
也会有不同的搜索词因为语意关联的缘故，他们的节点距离是很近的，照这个思路，有了以下的分布图。</p>
<p>网页结构化中伪匹配,节点距离兄弟距离的分布图图示如下：</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match3.png" alt="网页结构化中伪匹配节点距离兄弟距离的分布图" title="网页结构化中伪匹配节点距离兄弟距离的分布图"></p>
<p>这个尾部节点兄弟距离太大了，一定是伪匹配的的，看数据较小的距离分布。</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match4.png" alt="网页结构化中伪匹配节点距离兄弟距离的分布图" title="网页结构化中伪匹配节点距离兄弟距离的分布图"></p>
<p>从图可以看出，节点距离和伪匹配的关系不大，主要是兄弟距离起作用。</p>
<p>而兄弟距离于未匹配的分布图：</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match5.png" alt="兄弟距离于未匹配的分布图" title="兄弟距离于未匹配的分布图"></p>
<p>各个距离的直方图如下：</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match6.png" alt="兄弟距离于未匹配的直方图" title="兄弟距离于未匹配的直方图"></p>
<p>其中X轴是兄弟距离长度，y是个数。范围值可以选在3-28之间。</p>
<p>而在无结构中，搜索词的语意判断就是文本距离，搜索词的下标靠的很近。图示如下：</p>
<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match2.png" alt="间隔分布图" title="间隔分布图"></p>
<p>文本长度的数据（取一个网页中搜索词之间距离的最小值）为<code>4 13 25 58 89 102 249 893 1356 2000 2445 3023 4243 12533 13234</code>
,从这个可以看出，距离很大的肯定就是伪匹配了，最小值的这个不确定。</p>
<p>完整代码请看<a href="https://github.com/aluenkinglee/stuff/tree/master/java/match" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[朴素贝叶斯文本分类]]></title>
      <url>http://kinglanding.github.io/2014/06/27/2014-07-12-po-su-bei-xie-si-wen-ben-fen-lei/</url>
      <content type="html"><![CDATA[<p>回顾朴素贝叶斯(NB)分类器:</p>
<span>$$p(y_k|x)=\frac{p(y_k)p(x|y_k)}{p(x)}\propto p(y_k)p(x|y_k)=p(y_k)\prod_{i=1}^{d}{p(x_i|y_k)}$$</span><!-- Has MathJax -->
<p>对于文本分类任务,即对一篇文章进行分类,是 NLP 中最常见的机器学习任务。一般情况下,类别从几个到几十不等,或者更多。使用朴素贝叶斯文分类器进行文本分类,我们需要首先考虑特征是什么,即x如何表示;$p(x_i|y_k )$的物理意义是什么,如何计算。对于特征方面,文本分类常规都是使用 bag-of-words 的特征,即以文章中出现的词作为特征,而不考虑词语出现的顺序。朴素贝叶斯文分类器也一般使用这种形式。那么特征空间的大小,就取决于词表(vocabulary)的大小,即语料集合中不重复词的个数。对于汉语来说,一般几万到百万不等。</p>
<p>在 bag-of-words 的特征体系下,特征空间是确定了的,但是具体$x_i$的取值以及对应的$p(x_i |y_k )$的物理意义却可以有不同的考虑,对应着不同的参数计算公式及分类器训练和预测的实现。这取决于我们是否考虑词语在文章中出现的频次。</p>
<a id="more"></a>
<h4>伯努力(Bernoulli)NB</h4>
<p>先看不考虑词频的情况。即只看某词语在某文章中是否出现,而不管出现了具体是多少次。这种假设下,每维特征的取值为 0-1,此时对应的 NB 分类器又被称为伯努力(Bernoulli)NB 分类器。
比如,如果词表是{2014、年、巴西、世界杯、足球赛、举行、是、第、20、届、球队},某文档是“2014 年巴西世界杯足球赛是第 20 届世界杯足球赛 ”,那么特征空间是 11,该文档特征向量是:</p>
<p>$$
x = (1,1,1,1,1,0,1,1,1,1,0)
$$</p>
<p>此时,$p(x_i|y_k)$的物理意义可认为是:若文章为 k 类别,则第 i 特征(词表第 i 个词)出现或者不出现的概率。那么:
$$
p(x_i = 0|y_k ) = 1 − p(x_i = 1|y_k)
$$</p>
<p>习惯的,我们经常用$p(x_i |y_k )$来作为$p(x_i = 1|y_k)$同等含义的一种表示。那此时,原NB模型的表达式可以写为:</p>
<span>$$p\left( { { y }_{ k } }|{ x } \right) \propto 
p\left( { y }_{ k } \right) \prod _{ i=1 }^{ d }{ \left\{ { \alpha  }_{ i }p\left( { { x }_{ i } }|{ { y }_{ k } } \right) 
+\left( 1-{ \alpha  }_{ i } \right) \left( 1-p\left( { { x }_{ i } }|{ { y }_{ k } } \right)  \right)  \right\}  }$$</span><!-- Has MathJax -->
<p>$\alpha_i$ 表示第 i 个词在该文档中出现了,没出现则为0.此时要非常注意,计算文章属于某个类别的得分的时候,不只要考虑该文章的 word,还要考虑在词表中的但是在该文章中没出现的 word!这类词对得分的贡献是$1 − p(x_i |y_k )$。因此伯努力 NB 下,分类的时间复杂度是 $O(Cd)$,C 是类别数,d 是词表大小。</p>
<p>那么伯努力 NB 下,p的参数估计表达式是多少呢?假设根据如上定义,及最大似然估计,可以得到:</p>
<span>$$p\left( { { x }_{ i } }|{ { y }_{ k } } \right) 
=\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{t } \right\} I\{ x_{ i }\quad in\quad y_{ t }\}  }  }{ \sum _{ t=1 }^{ t }{ I\left\{ y_{ k }={ y }_{ t } \right\}  }  }
=\frac { 特征词i在第k类文章中出现的文章数 }{ 第k类文章数 }$$</span><!-- Has MathJax -->
<p>其中函数I是指示函数，若x出现则值为1。可见,对于高频词,对应的这种条件概率是非常高的。 比如“的”(假设没去除停用词),其对应的条件概率值很可能会接近于 1.</p>
<p>再重复强调一下,此时的概率意义约束是: $p(x_i = 1|y_k) + p(x_i = 0|y_k ) = 1$</p>
<p>看一下伯努力 NB 下参数平滑的问题。使用加 1 平滑,即拉普拉斯平滑,此时在保证概率意义下,其平滑公式应该为:</p>
<p>$$
p(x_i |y_k ) = \frac{第 k 类文章中出现过第 i 词的文章数 + 1}{第k类文章数 + 2}
$$</p>
<p>提醒一下,此处分母加的值是 2,而不是词表大小。注意,平滑一定要使得平滑之后仍满足概率意义。</p>
<h4>多项式(Multinomial)NB</h4>
<p>当我们考虑文章内词语的频次,而不只是考虑出现或未出现,此时特征的取值不再是 0-1,不过总的特征空间大小仍未变化。拿前面的例子来做对照,词表是{2014、年、巴西、世界杯、足球赛、举行、是、第、20、届、球队},某文档是“2014 年巴西世界杯足球赛是第 20 届世界杯足球赛”,此时该文章的特征向量为:</p>
<p>$$
x = (1,1,1,2,2,0,1,1,1,1,0)
$$</p>
<p>此时对应的 NB 一般称为多项式 NB。设 m 为文章内的总词频数,对应的模型表达式应该如下:</p>
<span>$$p(y_k|x)&prop;p(y_k)p(x|y_k)=p(y_k)
\frac{m!}{\prod_{i=1}^{d} x_i!}
\prod_{i=1}^{d}p(w_i|y_k)^{x_i}
&prop;p(y_k)\prod_{i=1}^{d}p(w_i|y_k)^{x_i}$$</span><!-- Has MathJax -->
<p>之所以可以省掉这个多项式系数,是因为它是和类别$y_k$无关的。而此时,第 k 类别的所有文章中第 i 词的分布概率:</p>
<span>$$p\left( { { w }_{ i } }|{ { y }_{ k } } \right)
 =\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }
{ \sum _{ j=1 }^{ d }{ \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }  } 
=\frac { 特征词i在第k类文章中出现的总词频数 }{ 第k文章总词频数 }$$</span><!-- Has MathJax -->
<p>在多项式NB下,即使极高频词,其$p(w_i|y_k)$也很难接近于 1,另外其在模型中作用的时候是:$p(w_i|y_k)^{x_i}$.这时候的概率约束是:</p>
<span>$\sum_{i=1}^{d}p(w_i|y_k)=1$</span><!-- Has MathJax -->
<p>因此对应的加 1 平滑为:</p>
<span>$$p\left( { { w }_{ i } }|{ { y }_{ k } } \right) =\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } } +1 }
{ \sum _{ j=1 }^{ d }{ \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }  +d}$$</span><!-- Has MathJax -->
<p>注意事项：</p>
<ul>
<li>
<p>训练时候对于词语平铺的文本,应该要做词的聚合,即行程 bag-of-words 的形式比较有利于后续统计计算,特别是对于伯努利 NB 必须做去重。当然,对于多项式 NB,也可以顺次扫描累加。</p>
</li>
<li>
<p>预测时候的概率连乘,为了防止精度损失,可以改用取 log 相加。</p>
</li>
<li>
<p>对于短一些的文本,伯努利 NB 即可;对于长文本,考虑词频的多项式 NB 即可。当然也可以使用 tf-idf 等特征值,仿照多项式 NB 的形式。</p>
</li>
<li>
<p>预测时候,对于词表中出现但是本文章未出现的词语,伯努利 NB 下对得分有贡献,多项式 NB 下不用考虑;对于在词表中未出现的词,都可以不予以考虑,因为未登录词对各个类别的贡献是一样的。</p>
</li>
</ul>
<h4>实验</h4>
<p>关于实验数据，可以到<a href="https://github.com/aluenkinglee/mlclass/tree/master/NativeBayes" target="_blank" rel="external">这里</a>下载，训练集和测试集都已经很明白
总量在4000-的水平，result.dat是训练结果，可以看到测试集在训练数据的结果上准确率达到了100%。。这个是因为类别太少的缘故。只有3个类别，不过这个已经
可以看到朴素贝叶斯在工业界的应用可以达到较好的性能。</p>
<p>朴素贝叶斯分类器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 训练目录下的样本集合</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trainSamples</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NaiveBayes classifier = <span class="keyword">new</span> NaiveBayes();</span><br><span class="line">        File flist = <span class="keyword">new</span> File(<span class="string">"./data-trainning-set"</span>);</span><br><span class="line">        <span class="keyword">for</span> (File f : flist.listFiles()) &#123;</span><br><span class="line">            classifier.training(<span class="keyword">new</span> Instance(f));</span><br><span class="line">        &#125;</span><br><span class="line">        classifier.save(<span class="keyword">new</span> File(<span class="string">"result.dat"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Trainning finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * specify the training dataset directory, and store result in the outfile</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> directory</span><br><span class="line">     * <span class="doctag">@param</span> result</span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trainSamples</span><span class="params">(String directory, String outfile)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NaiveBayes classifier = <span class="keyword">new</span> NaiveBayes();</span><br><span class="line">        File flist = <span class="keyword">new</span> File(directory);</span><br><span class="line">        <span class="keyword">for</span> (File f : flist.listFiles()) &#123;</span><br><span class="line">            classifier.training(<span class="keyword">new</span> Instance(f));</span><br><span class="line">        &#125;</span><br><span class="line">        classifier.save(<span class="keyword">new</span> File(outfile));</span><br><span class="line">        System.out.println(<span class="string">"Trainning finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断该实例所属的类别category</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> doc</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategory</span><span class="params">(Instance doc)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; categories = VARIABLE.getCategories();</span><br><span class="line">        System.out.println(categories);</span><br><span class="line">        <span class="keyword">double</span> best = Double.NEGATIVE_INFINITY;</span><br><span class="line">        String bestName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String c : categories) &#123;</span><br><span class="line">            <span class="keyword">double</span> current = getProbability(c, doc);</span><br><span class="line">            System.out.println(c + <span class="string">":"</span> + current);</span><br><span class="line">            <span class="keyword">if</span> (best &lt; current) &#123;</span><br><span class="line">                best = current;</span><br><span class="line">                bestName = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bestName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 计算P（C)=该类型文档总数/文档总数，返回的数对数值</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> category</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCategoryProbability</span><span class="params">(String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.log(VARIABLE.getDocCount(category) * <span class="number">1.0f</span></span><br><span class="line">                / VARIABLE.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 计算P(feature|cateogry),返回的是取对数后的数值</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> feature</span><br><span class="line">     * <span class="doctag">@param</span> category</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFeatureProbability</span><span class="params">(String feature, String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = VARIABLE.getFeatureCount();</span><br><span class="line">        <span class="keyword">return</span> Math.log((VARIABLE.getDocCount(feature, category) + <span class="number">1.0</span>)</span><br><span class="line">                / (VARIABLE.getDocCount(category) + m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 计算给定实例文档属于指定类别的概率，返回的是取对数后的数值</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> category</span><br><span class="line">     * <span class="doctag">@param</span> doc</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getProbability</span><span class="params">(String category, Instance doc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = getCategoryProbability(category);</span><br><span class="line">        <span class="keyword">for</span> (String feature : doc.getWords()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VARIABLE.containFeature(feature)) &#123;</span><br><span class="line">                result += getFeatureProbability(feature, category);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 加载训练结果</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> file</span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        VARIABLE = Variable.read(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 保存训练结果</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataOutput out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        VARIABLE.write(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 训练一篇文档</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> doc</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">training</span><span class="params">(Instance doc)</span> </span>&#123;</span><br><span class="line">        VARIABLE.addInstance(doc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>特征词类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 每个关键词在不同类别中出现的文档数量 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; docCountMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="comment">/** 特征名称 */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incDocCount</span><span class="params">(String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (docCountMap.containsKey(category)) &#123;</span><br><span class="line">            docCountMap.put(category, docCountMap.get(category) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            docCountMap.put(category, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDocCount</span><span class="params">(String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (docCountMap.containsKey(category)) &#123;</span><br><span class="line">            <span class="keyword">return</span> docCountMap.get(category);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(name == <span class="keyword">null</span> ? <span class="string">""</span> : name);</span><br><span class="line"></span><br><span class="line">        out.writeInt(docCountMap.size());</span><br><span class="line">        <span class="keyword">for</span> (String category : docCountMap.keySet()) &#123;</span><br><span class="line">            out.writeUTF(category);</span><br><span class="line">            out.writeInt(docCountMap.get(category));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = in.readUTF();</span><br><span class="line"></span><br><span class="line">        docCountMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = in.readInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String category = in.readUTF();</span><br><span class="line">            <span class="keyword">int</span> docCount = in.readInt();</span><br><span class="line">            docCountMap.put(category, docCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Feature <span class="title">read</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Feature f = <span class="keyword">new</span> Feature();</span><br><span class="line">        f.readFields(in);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多代码请看<a href="https://github.com/aluenkinglee/mlclass/tree/master/NativeBayes/src" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拉格朗日对偶]]></title>
      <url>http://kinglanding.github.io/2014/06/03/2014-06-03-lagrange-duality/</url>
      <content type="html"><![CDATA[<p>在解决约束最优化的额问题中，常常利用拉格朗日对偶性将原始问题转化为对偶问题，通过解对偶问题得到原始问题的解。该方法主要应用的SVM和最大熵模型中。</p>
<p>先抛开上面的二次规划问题，先来看看存在等式约束的极值问题求法，比如下面的最优化问题：</p>
<span>$\min _{ w }{ f\left( w \right)  } \\ s.t\quad h_{ i }\left( w \right) =0,\quad i=1,\cdots ,l$</span><!-- Has MathJax -->
<p>目标函数是f(w)，下面是等式约束。通常解法是引入拉格朗日算子，这里使用$$\beta$$来表示算子，得到拉格朗日公式为</p>
<a id="more"></a>
<span>$L \left( w,\beta  \right) =f\left( w \right) +\sum _{ i=1 }^{ l }{ \beta _{ i }h_{ i } } \left( w \right)$</span><!-- Has MathJax -->
<p>L是等式约束的个数。</p>
<p>然后分别对w和 $$\beta$$求偏导，使得偏导数等于0，然后解出w和 $\beta_i$。至于为什么引入拉格朗日算子可以求出极值，原因是f(w)
的dw变化方向受其他不等式的约束，dw的变化方向与f(w)的梯度垂直时才能获得极值，而且在极值处，f(w)的梯度与其他等式梯度的线性组合平行，因此他们之间存在线性关系。（参考《最优化与KKT条件》）
然后我们探讨有不等式约束的极值问题求法，问题如下：</p>
<p>$$
\min <em>{ w }{ f\left( w \right)  } \
s.t\quad h</em>{ i }\left( w \right) =0,\quad i=1,\cdots ,l\
\quad \quad \quad g_{ i }\left( w \right) \le 0,\quad i=1,\cdots ,k
$$</p>
<p>我们定义一般化的拉格朗日公式</p>
<p>$$
L\left( w,\beta  \right) =f\left( w \right) +\sum _{ i=1 }^{ k }{ \alpha <em>{ i }g</em>{ i } } \left( w \right) \sum _{ i=1 }^{ l }{ \beta <em>{ i }h</em>{ i } } \left( w \right)
$$</p>
<p>这里的$$\alpha _{ i } $$和$$\beta <em>{ i } $$ 都是拉格朗日算子。如果按这个公式求解，会出现问题，因为我们求解的是最小值，而这里的 $$g</em>{ i } \left( w \right) $$已经不是0了，我们可以将 $$\alpha _{ i } $$调整成很大的正值，来使最后的函数结果是负无穷。因此我们需要排除这种情况，我们定义下面的函数：</p>
<p>$$
{ \theta  }_{p  }\left( w \right) =\max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  }
$$</p>
<p>这里的P代表primal。假设$$g_{ i }\left( w \right)$$ &gt;0 或者$$h_{ i }\left( w \right) \neq 0$$ ，那么我们总是可以调整 $$\alpha_i$$和$$\beta_i$$ 来使得$$ { \theta  }<em>{ p  }\left( w \right)$$有最大值为正无穷。而只有g和h满足约束时，$$ { \theta  }</em>{ p }\left( w \right)$$ 为f(w)。这个函数的精妙之处在于 $$\alpha_i \ge 0$$，而且求极大值。</p>
<p>因此,</p>
<p>$$
{ \theta  }_{ p  }\left( w \right) =\begin{cases} f\left( w \right) ,\quad w满足原始问题约束 \ +\infty ，其他\quad  \end{cases}
$$</p>
<p>所以如果考虑极小化问题</p>
<p>$$
{ \min <em>{ w }{ { \theta  }</em>{p  }\left( w \right)  }  }={ \min _{ w }{ \max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  }  }  }
$$</p>
<p>它是原始问题的等价解，原始最优化问题转化成了拉格朗日函数的极小极大问题，这时候把原始问题的最优值记为：</p>
<p>$$
{ p }^{ \ast  }=\min <em>{ w }{ { \theta  }</em>{ p }\left( w \right)  }
$$</p>
<p>哎哟，看看我们的等价形式哦，首先有两个参数，其中还是一个不等式约束=。=,考虑下对偶吧，极小极大问题转化为等价的极大极小问题。</p>
<h4>对偶形式</h4>
<p>定义$${ \theta  }_{ D }\left( \alpha ,\beta  \right) =\min <em>{ w }{ L\left( w,\alpha ,\beta  \right)  } $$，在考虑极大化$${ \theta  }</em>{ D }\left( \alpha ,\beta  \right) $$,先把这两个参数看成固定值，求关于w的最小值，之后在求对偶的最大值即</p>
<p>$$
\max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ { \theta  }_{ D }\left( \alpha ,\beta  \right)  } =\max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ \min _{ w }{ L\left( w,\alpha ,\beta  \right)  }  }
$$</p>
<p>这个问题是原问题的对偶问题，相对于原问题只是更换了min和max的顺序，而一般更换顺序的结果是Max Min(X) &lt;= MinMax(X)。然而在这里两者相等。用$${ d }^{ \ast  }$$ 来表示对偶问题如下：</p>
<p>$$
{ d }^{ \ast  }=\max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ \min _{ w }{ L\left( w,\alpha ,\beta  \right)  }  } \le { \min _{ w }{ \max <em>{ \alpha ,\beta :{ \alpha  }</em>{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  }  }  }={ p }^{ \ast  }
$$</p>
<p>存在 $${ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }$$ 使得$${ w }^{ \ast  }$$是原问题的解，$${ \alpha }^{ \ast  },{ \beta }^{ \ast  }$$  是对偶问题的解。还有 $${ p }^{ \ast  }={ d}^{ \ast  } = L({ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  })$$</p>
<p>另外，  $${ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }$$ 满足库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition），该条件如下：</p>
<p>![库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition）](https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-06-03-lagrange-duality/kkt.png?raw=true 库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition）&quot;)</p>
<p>所以如果 $${ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }$$  满足了库恩-塔克条件，那么他们就是原问题和对偶问题的解。当$$g_{i}(w^{ \ast  })=0$$ 时，w处于可行域的边界上，这时才是起作用的约束。而其他位于可行域内部（ $$g_{i}(w^{ \ast  })&lt;0$$ 的）点都是不起作用的约束，其 $${ \alpha }^{ \ast  }=0$$。这个KKT双重补足条件会用来解释支持向量和SMO的收敛测试。</p>
<p>KKT的总体思想是将极值会在可行域边界上取得，也就是不等式为0或等式约束里取得，而最优下降方向一般是这些等式的线性组合，其中每个元素要么是不等式为0的约束，要么是等式约束。对于在可行域边界内的点，对最优解不起作用，因此前面的系数为0。</p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li>
<p>Andrew Ng的原始课件讲义</p>
</li>
<li>
<p>统计学习方法</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从逻辑回归分类到SVM分类]]></title>
      <url>http://kinglanding.github.io/2014/06/03/2014-06-03-my-understanding-about-svm/</url>
      <content type="html"><![CDATA[<p>上一章讲到了线性回归的一个典型算法，核心思想就是利用最小二乘法最为损失函数，不断使用梯度下降法（或者使用随机梯度下降法（stochastic gradient descent））来更新theta值。</p>
<p>后来降到了分类，逻辑回归只不过有个很好的性质就是值分布在0到1之间，正好可以利用到分类上。logistic回归就是要学习得到θ，使得正例的特征远大于 0，负例的特征远
小于 0，强调在全部训练实例上达到这个目标。为什么说逻辑回归是个线性模型？这是因为该模型是将特性的线性组合作为自变量，然后使用logistic函数（或者说是sigmoid函数）将自变量映射到（0-1）上，将值和概率结合之后从而应用到分类上。
函数表示形式：</p>
<p>$$
h_{ \theta  }\left( x \right) =g\left( \theta ^{ T }x \right) =\frac { 1 }{ 1+{e  }^{ -\theta^{T}x } }
$$</p>
<a id="more"></a>
<p>其中 x 是 n 维特征向量，函数 g 就是 logistic 函数
从线性回归到了逻辑回归，从逻辑回归又到了分类，那么再来看看SVM这个有监督的分类学习算法。
在这里我们使用的y的取值记为1和-1，所以对logistic 回归中的做下替换，令logistic回归中的y=0和y=1变为y=-1,y=1。同时将θ替换成 w 和 b。
所以有$$\Theta^{T}x=\theta_0x_0+\theta_1x_1+\cdots +\theta_nx_n$$，现在使用b替换$$\theta_0$$,替换后的形式变为$$w^{ T }x=w_{ 1 }x_{ 1 }+\cdots +w_{ n }x_{ n }+b$$，这样做之后，我们的假设函数就变成了</p>
<p>$$
h_{ b,w }\left( x \right) =g\left( w^{ T }x+b \right)
$$</p>
<p>和逻辑回归的形式很相像。</p>
<p>表达形式就引申到这里，在来谈下SVM的思想，当我们学习线性回归时，我们的想法就是使用最小二乘法拟合数据，而在分类问题中，我们的想法就是找到一条直线，使正负样本离这个线或者超平面尽可能的远。也就是<code>间隔</code>最大。用一句话来说就是：<strong>在特征空间上的间隔最大的线性分类器。所以我们所有的努力都在如何是间隔最大化上，而这个可以转化为一个凸二次规划的问题</strong>。所以SVM的学习算法就是求解凸二次规划的最优化算法。</p>
<h4>函数间隔（functional margin）和几何间隔（geometric margin）</h4>
<p>我们定义函数间隔就是：对于给定的数据集T和超平面（w,b），样本点$$\left( x^{(i)},y^{(i)} \right) $$到超平面的函数间隔为：
$$
\widehat { \gamma  } ^{ (i) }=y^{ (i) }(w^{T}\cdot x^{ (i) }+b)
$$</p>
<p>函数间隔或者间隔本身描述了一种确信度。离超平面越远，间隔值就越大，可信度就越大。</p>
<p>刚刚我们定义的函数间隔是针对某一个样本的，现在我们定义全局样本上的函数间隔，定义超平面关于数据集的函数间隔为超平面中所有样本点函数间隔的最小值，就是在训练样本上分类正例和负例确信度最小那个函数间隔，即</p>
<p>$$
\widehat {\gamma }=\min _{ i=1,...m }{ \widehat { \gamma  } ^{ (i) } }
$$</p>
<p>但是有个问题，如果按比例的增加w和b，那么函数间隔也会按比例改变，这个对结果没有影响，但是问题会变得不好描述，不能定量的计算，所以我们就需要把它规范化(normalization)。只需要结果除以$$\left| w \right| $$就好了，这个时候$$w/\left| w \right| $$就成为了单位向量，所以函数间隔和几何间隔的关系也就是这样简单，几何间隔就是规范化后的函数间隔。无论w和b怎么折腾，几何间隔都不会改变。</p>
<p>定义几何间隔就是：对于给定的数据集T和超平面（w,b），样本点$$\left( x^{(i)},y^{(i)} \right) $$到超平面的几何间隔为：</p>
<p>$$
{ \gamma  } ^{ (i) }=y^{ (i) }(w^{T}\cdot x^{ (i) }+b)/\left| w \right|
$$</p>
<p>定义超平面关于数据集的几何间隔为超平面中所有样本点几何间隔的最小值,即</p>
<p>$$
{ \gamma  }=\min _{ i=1,...m }{ { \gamma  }^{ (i) } }
$$</p>
<p>最优间隔分类器（optimal margin classifier）（利用间隔最大化）</p>
<p>回想前面我们提到我们的目标是寻找一个超平面，使得离超平面比较近的点能有更大的
间距。 也就是我们不考虑所有的点都必须远离超平面，我们关心求得的超平面能够让所有点中离它最近的点具有最大间距。形象的说，我们将上面的图看作是一张纸，我们要找一条折线，按照这条折线折叠后，离折线最近的点的间距比其他折线都要大。形式化表示为：</p>
<p>$$
\max _{ \gamma ,w,b }{ \gamma  } \ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) \ge \gamma ,i=1,\cdots ,m\ \left| w \right| =1
$$</p>
<p>这里用||w||=1 规约 w，使得$$ w^{T}\cdot x+b$$是几何间隔。</p>
<p>到此，我们已经将模型定义出来了。如果求得了 w 和 b，那么来一个特征 x，我们就能
够分类了，称为最优间隔分类器。接下的问题就是如何求解 w 和 b 的问题了。</p>
<p>由于||w|| = 1不是凸函数，我们想先处理转化一下，考虑几何间隔和函数间隔的关系，
$$ \gamma =\frac { \hat { \gamma  }  }{ \left| w \right|  } $$，我们改写一下上面的式子：</p>
<p>$$
\max _{ \gamma ,w,b }{ \frac { \widehat { \gamma  }  }{ \left| w \right|  }  } \ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) \ge \widehat { \gamma  } ,i=1,\cdots ,m
$$</p>
<p>因为函数间隔值得改变对结果没有影响，所以可以给它个固定值比如1.将 $$\hat { \gamma  } =1$$代入上面的最优化问题，因为最大化$$ \frac { 1 }{ \left| w \right|  } $$最小化$$ \frac { 1 }{ 2 } \left| w \right| ^{ 2 }$$是等价的，于是将上面改写成这样：</p>
<p>$$
\min _{ \gamma ,w,b }{ \frac { 1 }{ 2 }  } { \left| w \right|  }^{ 2 }\ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) -1\ge 0,i=1,\cdots ,m
$$</p>
<p>这就变成了一个凸二次规划问题，详情见<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92" target="_blank" rel="external">凸二次规划</a></p>
<p>接下来是关于拉格朗日对偶的问题，在这之后，在描述SVM中最简单的分类器——<strong>线性可分支持向量机</strong>，因为这个情况下，数据是线性可分的，而且噪音没有，只需要通过<strong>硬间隔最大化</strong>,即可学习一个线性的分类器，又称硬间隔支持向量机。</p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li>
<p>Andrew Ng的原始课件讲义</p>
</li>
<li>
<p>统计学习方法</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下通过端口杀死进程]]></title>
      <url>http://kinglanding.github.io/2014/05/20/2014-05-20-kill-process-on-some-port-under-linux-platform/</url>
      <content type="html"><![CDATA[<p>就是把一些常用命令记录下来拉。一直在用，可就是容易忘记命令。</p>
<p>floodlight 控制器启动之后，因为不正常的关闭程序（ctrl+c）造成6633端口还在被占用。</p>
<p>流程如下：</p>
<ol>
<li>
<p>netstat -nlp 查看占用端口号的服务</p>
</li>
<li>
<p>找到该端口号的进程，可以使用grep</p>
</li>
<li>
<p>找到该进程id</p>
</li>
<li>
<p>kill pid</p>
</li>
</ol>
<h5>查看占用端口号的服务</h5>
<p>可以使用netstat命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name  </span><br><span class="line">tcp        0      0 0.0.0.0:6633            0.0.0.0:*               LISTEN      6267/java              </span><br><span class="line">tcp        0      0 0.0.0.0:3307            0.0.0.0:*               LISTEN      12711/              </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3936/httpd          </span><br><span class="line">tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      3910/              </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      3753/sshd          </span><br><span class="line">tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      3786/</span><br></pre></td></tr></table></figure>
<h5>用管道符给grep处理</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlp | grep 6633</span><br></pre></td></tr></table></figure>
<p>既然取出一行了，那就容易了，再筛选一下，用awk分割取出其中一个</p>
<h5>读取出端口号</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlp | grep 6633 | awk <span class="string">'&#123;print $7&#125;'</span></span><br></pre></td></tr></table></figure>
<p>6267/java</p>
<p>意思是取第七个字段，这里默认应该是用tab字符分割的，已经读取出来了，但是还得拿到/前面的数字</p>
<h5>取/前面的数字就可以了，这里还是可以用awk处理</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlp | grep 6633 | awk <span class="string">'&#123;print $7&#125;'</span> | awk -F<span class="string">"/"</span> <span class="string">'&#123; print $1 &#125;'</span></span><br></pre></td></tr></table></figure>
<p>6267</p>
<h5>把这个数字传给kill就可以</h5>
<p>kill命令不能跟在管道符后面继续处理了，会出错的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [<span class="string">'] netstat -nlp | grep 6633 | awk '</span>&#123;<span class="built_in">print</span> <span class="variable">$7</span>&#125;<span class="string">' | awk -F"/" '</span>&#123; <span class="built_in">print</span> <span class="variable">$1</span> &#125;<span class="string">' ['</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其它类似的命令</p>
</blockquote>
<ol>
<li>查看端口属于哪个程序？端口被哪个进程占用</li>
</ol>
<p>也可以使用lsof命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i :6633</span><br><span class="line"></span><br><span class="line">COMMAND   PID   USER      FD   TYPE    DEVICE  SIZE/OFF NODE NAME</span><br><span class="line">java    7838   kinglee   50r   IPv6  35452317       0t0  TCP *:6633 (LISTEN)</span><br></pre></td></tr></table></figure>
<h3>reference</h3>
<ol>
<li>
<p><a href="http://baike.baidu.com/link?url=idG3yCyykQj00QVBW_jreekVZWjIGU5urL553dG9o4ZYgwpbnjd7jJ2DVjxrm5EZ" target="_blank" rel="external">netstat</a></p>
</li>
<li>
<p><a href="http://www.cnblogs.com/peter9/archive/2011/07/28/2362156.html" target="_blank" rel="external">Linux下通过端口杀死进程</a></p>
</li>
<li>
<p><a href="http://blog.csdn.net/andy572633/article/details/7211546" target="_blank" rel="external">linux下杀死进程（kill）的N种方法</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[threading:why import it into os]]></title>
      <url>http://kinglanding.github.io/2014/05/19/2014-05-19-threading-why-import-it-into-os/</url>
      <content type="html"><![CDATA[<p>线程的引入是为了提高CPU利用率。线程给操作系统带来的创建维护和管理负担要轻。因为与线程相关的信息比较少，交情的负担意味着线程的代价或开销比较少。当处理器除一个进程并激活另一个进程时，就要发生上下文切换。为了发生上下文切换，操作系统必须启动和重新启动每个进程所需的信息。这就意味着必须保存描述进程存在状态的有关信息，在进程再次激活时，就可以从离开的地点继续执行。</p>
<h4>那么系统在进程切换时需要保存那些信息呢？</h4>
<ol>
<li>
<p>所需信息包括可执行程序、堆栈、以及静态与动态分配变量内存的指针。</p>
</li>
<li>
<p>寄存器组中包含执行下一条指令的指针这样的信息 。</p>
</li>
<li>
<p>重新任命进程时需要进程的状态（进程是被挂起还是被阻塞）和优先权。同时程序的I/O状态也被保存。</p>
</li>
<li>
<p>保存进程的规划信息，内存管理信息以及计数信息。</p>
</li>
<li>
<p>进程需要文件描述器和读写指针来继续使用资源。</p>
</li>
</ol>
<h4>而线程同样需要上下文。当线程被抢先时同样也会发生上下文切换。</h4>
<h4>与进程相比线程的优势如下：</h4>
<ol>
<li>
<p>线程不需要地址空间。线程包含在进程的地址空间中。（所以在重新任命进程时所需的线程都不需要）</p>
</li>
<li>
<p>线程的上下文只包含一个堆栈、一个寄存器组和一个优先权。</p>
</li>
<li>
<p>寄存器组包含程序或指令指针以及堆栈指针。</p>
</li>
<li>
<p>线程的文本包含在他的进程的文本中。</p>
</li>
<li>
<p>进程拥有的所有资源都属于线程。所以与资源相关的所有信息不是线程上下文的部分。</p>
</li>
<li>
<p>其他信息如规划、计数等都是由进程所定义。无需包含在线程的上下文中。</p>
</li>
</ol>
<p>线程与进程的相同之处是：都有ID，寄存器组、状态、以及优先权。线程与子进程共享父进程的资源。</p>
<h4>他们的不同之处是：</h4>
<ol>
<li>
<p>线程没有自己的地址空间，如果进程创建了多个所有的线程都将包含在他的地址空间中。</p>
</li>
<li>
<p>父进程和子进程之间必须通过进程间通信机制来进行通信。而进程中的多个线程之间是通过读取和写入数据到进程变量来通信。</p>
</li>
<li>
<p>子进程对其他子进程不施加控制，而进程的线程被看做同位体（peer）并对进程的其他的线程施加控制。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我对KMP算法的理解]]></title>
      <url>http://kinglanding.github.io/2014/05/19/2014-05-19-my-understanding-about-kmp/</url>
      <content type="html"><![CDATA[<p>和朴素的字符串匹配算法相比，KMP加快匹配的关键在于当某个位置不匹配了，不在模版不再是向右滑动一个位置，而是跟匹配处相关的一个值。这样，在字符串的匹配时间就是和搜索串长度相关的一个值$$O(n)$$。</p>
<p>至于相关的资料，参阅了<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">六之再续：KMP算法之总结篇（12.09修订，必懂KMP</a>，只是这个个人感觉有点凌乱。</p>
<p>定义要搜索的字符串模式是$$P$$,搜索的源是文本$$T$$.那让我们看看next数组怎么诞生的。</p>
<h4>局部匹配表</h4>
<p>理解KMP算法的关键就是<strong>局部匹配表</strong>,或者形象的称作为<strong>next数组</strong>，
<a href="http://book.douban.com/subject/1885170/" target="_blank" rel="external">算法导论</a>p571页详细的描述了推导的过程，并给出了证明。但是仍然还是晦涩难懂的。</p>
<p>对于这个推论：设$$P$$是长度为$$m$$的模式，next是P的前缀函数，对于$$q=2,3,...,m$$</p>
<p>$$
next\left[ q \right] =\begin{Bmatrix} 0 &amp; \quad if\quad { E }<em>{ q }\quad =\quad \phi  \ 1+max{ k\in { E }</em>{ q-1 }}  &amp; \quad if\quad { E }_{ q-1 }\quad =\phi  \end{Bmatrix}
$$</p>
<p>直观来说就是才用动规的方法，求$$next\left[ q \right]$$的最长前缀的长度。</p>
<p>那么好吧，再来个直观点的手写算法吧╮(╯▽╰)╭。</p>
<p>就以书上的例子为准，见下图。</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/1.png?raw=true" alt="a)" title="a)"></p>
<p>前q=5个字符匹配，标记为绿色。</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/2.png?raw=true" alt="b)" title="b)"></p>
<p>很明显，s+1的位置是无效的，但是s+2的位置很有可能是有效的，所以，可以直接向右移动2个位置。</p>
<p>推导中的使用的有用信息可以通过模式自身的比较来预处理计算得到。在这里，可以发现P的最长前缀同时也是$$P_5$$的一个真后缀$$P_3$$.这些信息可以预先急死俺，用数组next来表示，next[5]=3. 一般化的公式为，在位移s处有q个字符成功匹配，囊而下个有可能有效的位移是$$s=s-(q-next[q])$$.</p>
<p>上面提到了<strong>真后缀</strong>,让我们给出定义来。</p>
<p><strong>真前缀</strong>： 字符串中去除1个至多个尾部字符的字符串集合。比如aabac的真前缀为a,aa,aab,aaba.</p>
<p><strong>真后缀</strong>： 字符串中去除1个至多个头部字符的字符串集合。比如aabac的真后缀为c,ac,bac,abac.</p>
<p>好了 ，有了上面的定义，我们就可以简单，最重要的是明白计算next值了：<code>某个位置的next值为，到此位置的字符串产生的真前缀和真后缀</code><strong>并集</strong><code>中的最长元素的长度</code>。</p>
<p>就比如上面的那个例子，模式串为&quot;ababaca&quot;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot;的真前缀和真后缀都为空集，next[0]=0;</span><br><span class="line"></span><br><span class="line">&quot;ab&quot;的真前缀为[b],真后缀为[a], next[1]=0;</span><br><span class="line"></span><br><span class="line">&quot;aba&quot;的真前缀为[a,ab],真后缀为[a,ba],next[2]=1;</span><br><span class="line"></span><br><span class="line">&quot;abab&quot;的真前缀为[a,ab,aba],真后缀为[b,ab,bab],next[3]=2;</span><br><span class="line"></span><br><span class="line">&quot;ababa&quot;的真前缀为[a,ab,aba,abab],真后缀为[baba,aba,ba,a],next[4]=3;</span><br><span class="line"></span><br><span class="line">&quot;ababac&quot;的真前缀为[a,ab,aba,abab,ababa],真后缀为[babac,abac,bac,ac,c],next[5]=0;</span><br><span class="line"></span><br><span class="line">&quot;ababaca&quot;的真前缀为[a,ab,aba,abab,ababa,ababac],真后缀为[babaca,abaca,baca,aca,ca,a],next[5]=1;</span><br></pre></td></tr></table></figure>
<h4>如何使用</h4>
<p>见上面的例子吧，很好理解不是。</p>
<p>对了一下是代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_prefix</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">int</span> *next)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">int</span> k =<span class="number">0</span>,q;</span><br><span class="line">    <span class="keyword">for</span>(q=<span class="number">1</span>; q &lt; len; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///前q个字符中，前缀字符串集和后缀字符串集中最长的交集元素的长度</span></span><br><span class="line">        <span class="keyword">while</span>( (k &gt; <span class="number">0</span>) &amp;&amp; (p[k] != p[q]) )</span><br><span class="line">            k = next[k<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/// 请看前面的那个状态转移函数的公式</span></span><br><span class="line">        <span class="keyword">if</span>( p[k] == p[q] )</span><br><span class="line">            k=k+<span class="number">1</span>;</span><br><span class="line">        next[q] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T, <span class="keyword">const</span> <span class="keyword">char</span>* P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">int</span> m=<span class="built_in">strlen</span>(P);</span><br><span class="line">    <span class="keyword">int</span> *next = new <span class="keyword">int</span>[m];</span><br><span class="line">    compute_prefix(P, next);</span><br><span class="line">    <span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">0</span> &amp;&amp; P[q]!=T[i])</span><br><span class="line">            q=next[q<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(P[q]==T[i])</span><br><span class="line">            q=q+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q==m)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"math occurs with "</span>&lt;&lt;i-m+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            q=next[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"there is no math!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>总结</h4>
<p>相对于朴素的匹配算法，这里并不是在匹配失败后直接无脑的外后移一位就可以了，而是利用了模式串本身的信息，<strong>位移的距离=已经匹配的长度-该位置next值</strong>。</p>
<p>希望对你有用。当然要是觉得有问题直接留言好了，一起学吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[链表排序]]></title>
      <url>http://kinglanding.github.io/2014/05/14/2014-07-14-sort-list/</url>
      <content type="html"><![CDATA[<p>链表不想数组那样是连续的即像数组那样随机访问，只能从前往后遍历。所以排序的方法只能是像插入排序，选择排序，和归并排序。</p>
<p>下面就先说归并排序。</p>
<a id="more"></a>
<p>简单的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思想很简单，就是找到链表的中点，然后左右递归排序，最后合并。
详情还是看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@param</span> head</span><br><span class="line"> * <span class="doctag">@return</span> 链表中点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode cur = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode leftHead, ListNode rightHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头部节点，本身没有用处，只是为了让代码更简便</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (leftHead != <span class="keyword">null</span> &amp;&amp; rightHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftHead.val &lt; rightHead.val) &#123;</span><br><span class="line">            cur.next = leftHead;</span><br><span class="line">            leftHead = leftHead.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = rightHead;</span><br><span class="line">            rightHead = rightHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.next = leftHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.next = rightHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单个节点直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode mid = middle(head);</span><br><span class="line">        ListNode after = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line">        head = sortList(head);</span><br><span class="line">        after = sortList(after);</span><br><span class="line">        head = merge(head, after);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试样例：边界值
2 1
1
2 -1 1</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[generative method]]></title>
      <url>http://kinglanding.github.io/2014/04/30/2014-04-30-generative-method/</url>
      <content type="html"><![CDATA[<p>线性回归模型和logistic回归是判别模型，也就是根据特征值来求结果的概率。形式化表
示为$$p(y|x;\theta)$$在参数$$\theta$$确定的情况下，求解条件概率$$p(y|x)$$。
通俗的解释为在给定特征后预测结果出现的概率。</p>
<p>就按照Andrew Ng讲的那样，确定肿瘤是良性的还是恶性的，可以使用判别模型的方法是先
从历史数据中学习到模型，然后通过提取肿瘤的特征来预测出它是良性恶性的概率。</p>
<p>反过来，要是我们先从良性肿瘤学习出良性肿瘤的模型，从恶性肿瘤学习出恶性肿瘤的模型，
然后提取肿瘤的特征，放到良性肿瘤的模型看下概率，在放到恶性肿瘤的模型看下概率，哪个
大是哪个。</p>
<p>形式化表示为求$$P(X|Y)$$,x是特征，y是类型即模型。
利用贝叶斯公式发现两个模型的统一性：</p>
<p>$$
p(y|x)=\frac { p(x|y)p(y) }{ p(x) }
$$</p>
<p>由于我们关注的是 y 的离散值结果中哪个概率大（比如良性肿瘤和恶性肿瘤哪个概率大），
而并不是关心具体的概率，因此上式改写为：</p>
<p>$$
\quad \quad \quad \quad \begin{eqnarray} \max _{ y }{ p(y|x) }  &amp; = &amp; \max _{ y }{ \frac { p(x|y)p(y) }{ p(x) }  }  \  &amp; = &amp;\max _{ y } p(x|y)p(y) \end{eqnarray}
$$</p>
<p>其中$$p(x|y)$$称为后验概率,$$p(y)$$称为先验概率.</p>
<p>由$$p(x|y)*p(y)=p(x,y)$$,因此有时称判别模型求的是条件概率，生成模型求的是联
合概率。</p>
<p>常见的判别模型有线性回归、对数回归、线性判别分析、支持向量机、boosting、条件
随机场、神经网络等。</p>
<p>常见的生产模型有隐马尔科夫模型、朴素贝叶斯模型、高斯混合模型、LDA、Restricted
Boltzmann Machine 等。</p>
<p>上篇博客较为详细地介绍了两个模型</p>
<h3>高斯判别分析（Gaussian discriminant analysis）</h3>
<h4>多维正太分布</h4>
<p>多变量正态分布描述的是n维随机变量的分布情况。所以这里的$$\mu $$变成了n维随机变量，$$\sigma $$也变成了
矩阵$$\Sigma $$.记做$$N(\mu,\Sigma)$$.假设有 n 个随机变量$$X_1,X_2,\cdots ,X_n$$.所以显而易见，$$\mu $$的第i个分量是$$E(X_i),\Sigma_{ii}=Var(X_i),\Sigma_{ij}=Cov(X_i,X_j)$$.</p>
<p>概率密度函数如下：</p>
<p>$$
p(x;\mu,\Sigma)=\frac { 1 }{ \left( 2\pi  \right) ^{ n/2 }\left| \Sigma  \right| ^{ 1/2 } } exp\left( -\frac { 1 }{ 2 } \left( x-\mu \right)^T \Sigma^{-1}{\left(x-\mu\right)} \right)
$$</p>
<h4>模型分析与应用</h4>
<p>如果输入特征x连续型随机变量，那么可以使用高斯判别分析模型来确定$$p(x|y)$$。模型如下,先以二元分布即伯努利分布来说（因为前面的例子是二元的）:</p>
<p>$$
y\sim Bernoulli\left( \phi \right) \
x|y=0\sim N(\mu_0,\Sigma)\
x|y=1\sim N(\mu_1,\Sigma)
$$</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Discriminative Model Vs. Generative Model]]></title>
      <url>http://kinglanding.github.io/2014/04/30/2014-04-30-discriminative-model-vs-generative-model/</url>
      <content type="html"><![CDATA[<h2>判别模型和生成模型分析</h2>
<p>在学习复习ML内容时，中文检索生成模型搜到了该<a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=248173&amp;do=blog&amp;id=227964" target="_blank" rel="external">这里</a>本文主要参考该文章，并稍作整理。</p>
<a id="more"></a>
<p>这两者进行预测的方式不同在于模型的处理上：</p>
<p><strong>生成模型</strong>：无穷样本 ==&gt; 概率密度模型 = 产生模型 ==&gt; 预测</p>
<p><strong>判别模型</strong>：有限样本 ==&gt; 判别函数 = 预测模型 ==&gt; 预测</p>
<p>简单的说，假设$$x$$是观察值，$$y$$是模型。</p>
<p>如果对先验概率$$P(x|y)$$建模，就是<strong>生成模型（Generative modle）</strong>。
其基本思想是首先建立样本的概率密度模型，再利用模型进行推理预测。要求已知样本无穷或尽可能的大。
这种方法一般建立在统计力学和bayes理论的基础之上。</p>
<p>如果对条件概率(后验概率)$$P(y|x)$$建模，就是<strong>判别模型（Discrminative modle）</strong>。基本思想是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。代表性理论为统计学习理论。
这两种方法目前交叉较多。</p>
<h3>判别模型Discriminative Model</h3>
<p>又可以称为条件模型，或条件概率模型。估计的是条件概率分布(conditional distribution)，即$$ p(class|context)$$。按照上文的记法就是$$P(y|x)$$
利用正负例和分类标签，焦点在判别模型的边缘分布。目标函数直接对应于分类准确率。</p>
<h4>主要特点：</h4>
<p>寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。</p>
<h4>优点:</h4>
<ol>
<li>
<p>分类边界更灵活，比使用纯概率方法或生产模型得到的更高级。</p>
</li>
<li>
<p>能清晰的分辨出多类或某一类与其他类之间的差异特征</p>
</li>
<li>
<p>在聚类、viewpoint changes, partial occlusion and scale variations中的效果较好</p>
</li>
<li>
<p>适用于较多类别的识别</p>
</li>
<li>
<p>判别模型的性能比生成模型要简单，比较容易学习</p>
</li>
</ol>
<h4>缺点:</h4>
<ol>
<li>
<p>不能反映训练数据本身的特性。能力有限，可以告诉你的是1还是2，但没有办法把整个场景描述出来。</p>
</li>
<li>
<p>Lack elegance of generative: Priors, 结构, 不确定性</p>
</li>
<li>
<p>Alternative notions of penalty functions, regularization, 核函数</p>
</li>
<li>
<p>黑盒操作: 变量间的关系不清楚，不可视</p>
</li>
</ol>
<p><strong>常见的机器学习方法</strong>：</p>
<ol>
<li>
<p>logistic regression</p>
</li>
<li>
<p>支持向量机（SVM）</p>
</li>
<li>
<p>传统的神经网络（traditional neural networks）</p>
</li>
<li>
<p>K近邻，最近邻（Nearest neighbor）</p>
</li>
<li>
<p>Conditional random fields(CRF): 目前最新提出的热门模型，从NLP领域产生的，正在向ASR和CV上发展。</p>
</li>
</ol>
<h4>主要应用：</h4>
<ol>
<li>
<p>图像文本分类</p>
</li>
<li>
<p>生物科学分析</p>
</li>
<li>
<p>时间序列预测</p>
</li>
</ol>
<h3>生成模型Generative Model</h3>
<p>估计的是联合概率分布（joint probability distribution），$$p(class, context)=p(class|context)*p(context)$$,换用之前的描述就是$$p(y, x)=p(y|x)*p(x)$$.</p>
<p>用于随机生成的观察值建模，特别是在给定某些隐藏参数情况下。在机器学习中，或用于直接对数据建模（用概率密度函数对观察到的draw建模），或作为生成条件概率密度函数的中间步骤。通过使用<strong>贝叶斯定律</strong>可以从生成模型中得到条件分布。</p>
<p>如果观察到的数据是完全由生成模型所生成的，那么就可以拟合生成模型的参数，从而仅可能的增加数据相似度。但观测数据往往完全从生成模型得到，所以比较准确的方式是直接对条件密度函数建模，即使用分类或回归分析。</p>
<h4>主要特点:</h4>
<ol>
<li>
<p>一般主要是对<strong>后验概率</strong>建模，从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度</p>
</li>
<li>
<p>只关注自己的inclass本身（即点左下角区域内的概率），不关心到底判别边界在哪</p>
</li>
</ol>
<h4>优点:</h4>
<ol>
<li>
<p>模型可以通过增量学习得到（同意！）</p>
</li>
<li>
<p>研究单类问题比判别模型灵活性强(怀疑？)</p>
</li>
<li>
<p>能用于数据不完整（missing data）情况(怀疑？)</p>
</li>
<li>
<p>实际上带的信息要比判别模型丰富（多太多！同意！）</p>
</li>
<li>
<p>prior knowledge can be easily taken into account（同意！）</p>
</li>
<li>
<p>modular construction of composed solutions to complex problems</p>
</li>
<li>
<p>robust to partial occlusion and viewpoint changes</p>
</li>
<li>
<p>can tolerate significant intra-class variation of object appearance</p>
</li>
</ol>
<h4>缺点:</h4>
<ol>
<li>学习和计算过程比较复杂</li>
</ol>
<p><strong>常见的机器学习方法</strong>：</p>
<ol>
<li>
<p><strong>Gaussians判别分析</strong></p>
</li>
<li>
<p>** Naive Bayes**， Bayesian networks</p>
</li>
<li>
<p>Mixtures of Gaussians（混合高斯模型）</p>
</li>
<li>
<p>HMMs，Markov random fields</p>
</li>
<li>
<p>Sigmoidal belief networks</p>
</li>
</ol>
<h3>两者之间的关系</h3>
<p><strong>由生成模型可以得到判别模型，但由判别模型得不到生成模型。</strong></p>
<blockquote>
<p>参考</p>
</blockquote>
<p>http://prfans.com/forum/viewthread.php?tid=80</p>
<p>http://hi.baidu.com/cat_ng/blog/item/5e59c3cea730270593457e1d.html</p>
<p>http://en.wikipedia.org/wiki/Generative_model</p>
<p>http://blog.csdn.net/yangleecool/archive/2009/04/05/4051029.aspx</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dynamic programming]]></title>
      <url>http://kinglanding.github.io/2014/04/29/2014-04-29-dynamic-programming/</url>
      <content type="html"><![CDATA[<p>好几年了，没有特意去做与ACM相关的算法题了，时至今日，也确实忘得差不多了，不过，现在也到了该拾起来的时候了。</p>
<h5>动态规划</h5>
<a id="more"></a>
<p>动态规划（Dynamic Programming）是用来解决最优化问题的最常用手段,说起定义，网上浩瀚如烟，有很多类型，比如：</p>
<ul>
<li>
<p>背包问题：0-1背包，完全背包，硬币问题，装箱子问题等。</p>
</li>
<li>
<p>最短路径问题：网络流等。</p>
</li>
<li>
<p>树形动规：最优查找树。</p>
</li>
</ul>
<p>等等等等，严格的划分问题类型没有意义，关键是分析问题的本质：阶段，状态，状态转移，全局最优。</p>
<h5>一些术语</h5>
<p>首先，先介绍下相关的概念，在结合具体的，例子加深感性和理性上的认识。</p>
<p>动态规划问题的一个通用特点是具备<code>最优子结构</code>和<code>重叠子问题</code>。当前子问题的解将由上一次子问题的解推出。每一个问题对应一个它的<strong>状态</strong>。<code>重叠子问题</code>的意思，某些问题的计算是有重叠的，若该计算结果记录下来，之后其他子问题遇到重叠的直接查表就可以了，避免重复计算。最优子结构则是我们的全局问题可以分解，按照<strong>阶段</strong>来分解。从而规约到最简的问题。说到这，是不是想到了分治法？，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次（把它们记录下来嘛！）。而且另外一个思想是，动规有明显的阶段的概念，而分治只是把问题分成不重复的规模较小的没有阶段概念的小问题。</p>
<p><strong>基本结构</strong></p>
<p>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。</p>
<p><strong>什么是动态规划，我们要如何描述它?</strong></p>
<p>先来看下形式化的描述的吧，在结合例子描述它。</p>
<p>$$
f\left( S \right) =\underset { d\in D\left( S \right)  }{ opt } \left{ cos\left( d\vert S \right) \quad \circ \quad f\left( T\left( d|S \right)  \right)  \right}
$$</p>
<p>其中，<code>S</code>是代指<code>state</code>，就是状态空间的一个state，动态规划解决的问题是按照状态和该状态可以选择的决策来解决问题的。确切的来说，<code>S</code>代表的就是从开始到当前决策的问题状态；</p>
<p><code>d</code>代指<code>decision</code>，是一个从<code>S</code>状态所决定的决策空间中$$D\left( S \right) $$做出的决策，不同状态决定的决策空间有可能不同。举例说明，对于硬币问题来讲，假设每个硬币的个数都是无限的，那么对于任何一个状态（目前手里有多少钱），接下来做的决策个数都是一样的，都是从固定的那几枚硬币中挑选；对于不可重复选择的问题，比如拿球，有红黑黄3个球，每个球的权值不同，求一个选球次序使之最优，这下好了，每个阶段的决策空间都是不同的，对于状态1，有红，黑，黄三种状态，接下来，就只能选剩下的球里面的了。所以决策空间会因问题而变化的。还有TSP旅行者问题，在每个节点所对应的状态时从起点到当前状态的最短距离，接下来的选择，得看该节点（状态）的出度是谁了。<strong>所以说，决策依赖当前的状态</strong>。</p>
<p>$$D\left( S \right) $$是决策空间(decision space)，代表从当前状态转到另一个状态时，或者从另一个状态转到当前状态可以选择的决策<code>d</code>的结合。（之所以使用或者是说了两种考虑的方式）</p>
<p><code>f</code>是指目标函数(target function)，一个关于状态的函数，往往代表从初始状态到达状态<code>S</code>所做的所有决策中的最优利益（不是最大就是最小）。</p>
<p>$$cos\left( d\vert S \right) $$可以叫做成本函数(cost function)，很好理解，就是在状态<code>S</code>下，做出选择<code>d</code>的成本，成本函数和目标函数不同，因为它不需要依赖上下文条件，只需一步计算就可以搞定。</p>
<p>$$cos\left( d\vert S \right) $$代表的是转移函数(transfer function)，就是指从S做一个决策到达另外一个状态$$S'$$.</p>
<p>$$\circ$$是一个二元操作符，多数是加法或者乘法或者是最大值要不就是最小值。</p>
<p>除此之外，还需要边界条件。</p>
<p>最后来看个最简单的例子。</p>
<h5>例子</h5>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？有多少种兑换方法？</p>
<p>思路：这个比较简单，状态就是硬币的价值，有多少钱，决策空间是固定的$$D(S)={1,3,5}$$</p>
<p>用$$f(i)$$代表凑够i元，得用最少多少硬币。成本函数也是固定的，为1。</p>
<p>$$
f(i)=\underset { d\in D\left( {1,3,5} \right)  }{min}{1+f(i-d)},i!=0
$$</p>
<p>当然了$$i==0$$时，f(0)=0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f(11)=min&#123;1+f(11-1),1+f(11-3),1+f(11-5)&#125;;</span><br><span class="line">f(10)=min&#123;1+f(10-1),1+f(10-3),1+f(10-5)&#125;;</span><br><span class="line">f(9)=min&#123;1+f(9-1),1+f(9-3),1+f(9-5)&#125;;</span><br><span class="line">f(8)=min&#123;1+f(8-1),1+f(8-3),1+f(8-5)&#125;;</span><br><span class="line">f(7)=min&#123;1+f(7-1),1+f(7-3),1+f(7-5)&#125;;</span><br><span class="line">f(6)=min&#123;1+f(6-1),1+f(6-3),1+f(6-5)&#125;;</span><br><span class="line">f(5)=min&#123;1+f(5-1),1+f(5-3),1+f(5-5)&#125;;</span><br><span class="line">f(4)=min&#123;1+f(4-1),1+f(4-3) )&#125;;</span><br><span class="line">f(3)=min&#123;1+f(3-1),1+f(3-3) )&#125;;</span><br><span class="line">f(2)=min&#123;1+f(2-1)&#125;;</span><br><span class="line">f(1)=min&#123;1+f(1-1)&#125;;</span><br><span class="line">f(0)已知=0；</span><br></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f(1)=min&#123;1+f(1-1)&#125;=1；</span><br><span class="line">f(2)=min&#123;1+f(2-1)&#125;=2；</span><br><span class="line">f(3)=min&#123;1+f(3-1),1+f(3-3) )&#125;=min&#123;3,1&#125;=1;</span><br><span class="line">f(4)=min&#123;1+f(4-1),1+f(4-3) )&#125;=min&#123;2,2&#125;=2;</span><br><span class="line">f(5)=min&#123;1+f(5-1),1+f(5-3),1+f(5-5)&#125;=min&#123;3,3,1&#125;=1;</span><br><span class="line">f(6)=min&#123;1+f(6-1),1+f(6-3),1+f(6-5)&#125;=min&#123;2,2,2&#125;=2;</span><br><span class="line">f(7)=min&#123;1+f(7-1),1+f(7-3),1+f(7-5)&#125;=min&#123;3,3,3&#125;=3;</span><br><span class="line">f(8)=min&#123;1+f(8-1),1+f(8-3),1+f(8-5)&#125;=min&#123;4,2,2&#125;=2;</span><br><span class="line">f(9)=min&#123;1+f(9-1),1+f(9-3),1+f(9-5)&#125;=min&#123;3,3,3&#125;=3;</span><br><span class="line">f(10)=min&#123;1+f(10-1),1+f(10-3),1+f(10-5)&#125;=min&#123;4,4,2&#125;=2;</span><br><span class="line">f(11)=min&#123;1+f(11-1),1+f(11-3),1+f(11-5)&#125;=min&#123;3,3,3&#125;=3;</span><br></pre></td></tr></table></figure>
<p>从我们的计算过程来看，求解既可以从前往后也可以从后往前。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[some commen list problems in the interview]]></title>
      <url>http://kinglanding.github.io/2014/04/28/2014-04-28-some-commen-list-problems-in-the-interview/</url>
      <content type="html"><![CDATA[<p>链表是最基本的数据结构，面试官也常常用链表来考察面试者的基本能力，而且链表相关的操作相对而言比较简单，也适合考察写代码的能力。链表的操作也离不开指针，指针又很容易导致出错。综合多方面的原因，链表题目在面试中占据着很重要的地位。本文对链表相关的面试题做了较为全面的整理，希望能对找工作的同学有所帮助。
链表结点声明如下：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///=======链表</span></span><br><span class="line"><span class="keyword">struct</span> ListNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ListNode * next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5>求单链表中结点的个数</h5>
<p>最最基本的，应该能够迅速写出正确的代码，注意检查链表是否为空。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 求单链表中结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getListLenght</span><span class="params">(ListNode* head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">for</span>(; current != <span class="literal">NULL</span>; len++)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    return len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>将单链表反转</h5>
<p>从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将单链表反转</span></span><br><span class="line"><span class="function">ListNode * <span class="title">reverseList</span><span class="params">(ListNode * head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/// 边界</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="comment">/// 反转后的新链表头指针，初始为NULL</span></span><br><span class="line">    ListNode* rHead = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* temp  = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">/// 将废弃结点摘下，插入新链表的最前端</span></span><br><span class="line">        temp-&gt;next = rHead;</span><br><span class="line">        rHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return rHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>查找单链表中的倒数第K个结点（k &gt; 0）</h5>
<p>主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差
是k - 1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  查找单链表中的倒数第K个结点（k &gt; 0）</span></span><br><span class="line"><span class="function">ListNode * <span class="title">getRKthNode</span><span class="params">(ListNode * head, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="literal">NULL</span>) <span class="comment">/// 这里k的计数是从1开始的，若k为0或链表为空返回NULL</span></span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* ahead = head;</span><br><span class="line">    ListNode* behind = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; ahead!=<span class="literal">NULL</span> &amp;&amp; k &gt; <span class="number">0</span> ; --k)   <span class="comment">/// 遍历完前k个节点</span></span><br><span class="line">        ahead = ahead-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>( k &gt; <span class="number">0</span>  )            <span class="comment">/// 结点个数小于k，返回NULL</span></span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(ahead != <span class="literal">NULL</span>)    <span class="comment">/// 前后两个指针一起向前走，直到前面的指针指向NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        ahead = ahead-&gt;next;</span><br><span class="line">        behind = behind-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return behind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>查找单链表的中间结点</h5>
<p>也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  查找单链表的中间结点</span></span><br><span class="line"><span class="comment">///  获取单链表中间结点，若链表长度为n(n&gt;0)，则返回第n/2+1个结点</span></span><br><span class="line"><span class="function">ListNode * <span class="title">getMidNode</span><span class="params">(ListNode * head )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/// 边界值处理，空或者只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode* ahead = head;</span><br><span class="line">    ListNode* behind = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 注意判断条件</span></span><br><span class="line">    <span class="keyword">while</span>(ahead != <span class="literal">NULL</span>)    <span class="comment">/// 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步</span></span><br><span class="line">    &#123;</span><br><span class="line">        ahead = ahead-&gt;next;</span><br><span class="line">        behind = behind-&gt;next;</span><br><span class="line">        <span class="comment">/// 注意判断条件</span></span><br><span class="line">        <span class="keyword">if</span>(ahead != <span class="literal">NULL</span>)</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return behind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>从尾到头打印单链表</h5>
<p>顺序颠倒，使用栈。系统栈或者自己写栈用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 逆序打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList2</span><span class="params">(ListNode* head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; s;</span><br><span class="line">    ListNode * tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push(tmp);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList3</span><span class="params">(ListNode* head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        return;</span><br><span class="line">    RPrintList3(head-&gt;next);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;head-&gt;data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</h5>
<p>类似归并排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</span></span><br><span class="line"><span class="comment">/// 会改变原有链表结构，妥妥的</span></span><br><span class="line"><span class="function">ListNode * <span class="title">MergeSortedList</span><span class="params">(ListNode * head1, ListNode * head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="literal">NULL</span>)</span><br><span class="line">        return head2;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="literal">NULL</span>)</span><br><span class="line">        return head1;</span><br><span class="line">    ListNode* mergeHead = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1-&gt;data &gt; head2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head1;</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">        mergeHead-&gt;next = <span class="literal">NULL</span>; <span class="comment">/// 注意语句顺序，防止head1变成悬空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head2;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">        mergeHead-&gt;next = <span class="literal">NULL</span>; <span class="comment">/// 注意语句顺序，防止head2变成悬空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    temp = mergeHead;</span><br><span class="line">    <span class="keyword">while</span>(head1 != <span class="literal">NULL</span> &amp;&amp; head2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head1-&gt;data&gt;head2-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = head1;</span><br><span class="line">            head1 = head1-&gt;next;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">            temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = head2;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">            temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head1!=<span class="literal">NULL</span>)</span><br><span class="line">        temp-&gt;next = head1;</span><br><span class="line">    <span class="keyword">if</span>(head2!=<span class="literal">NULL</span>)</span><br><span class="line">        temp-&gt;next = head2;</span><br><span class="line">    return mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</span></span><br><span class="line"><span class="function">ListNode * <span class="title">MergeSortedList2</span><span class="params">(ListNode * head1, ListNode * head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="literal">NULL</span>)</span><br><span class="line">        return head2;</span><br><span class="line">    <span class="keyword">if</span>(head2 == <span class="literal">NULL</span>)</span><br><span class="line">        return head1;</span><br><span class="line">    ListNode* mergeHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head1-&gt;data &gt; head2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head1;</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">        mergeHead-&gt;next = MergeSortedList2(head1,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head2;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">        mergeHead-&gt;next = MergeSortedList2(head1,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    return mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>判断两个单链表是否相交</h5>
<p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。
也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住
最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比
较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指
针保存最后一个节点地址，空间复杂度为O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersected</span><span class="params">(ListNode * head1, ListNode * head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="literal">NULL</span> || head2 == <span class="literal">NULL</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    ListNode* tail1=head1;</span><br><span class="line">    ListNode* tail2=head2;</span><br><span class="line">    <span class="keyword">while</span>(tail1 != <span class="literal">NULL</span>)</span><br><span class="line">        tail1 = tail1-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tail2 != <span class="literal">NULL</span>)</span><br><span class="line">        tail2 = tail2-&gt;next;</span><br><span class="line">    <span class="comment">///若相交，尾节点可定相同</span></span><br><span class="line">    return (tail1 == tail2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>求两个单链表相交的第一个节点</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFirstIntersectedNode</span><span class="params">(ListNode * head1, ListNode * head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/// 边界值检查</span></span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="literal">NULL</span> || head2 == <span class="literal">NULL</span>)</span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* tail1=head1;</span><br><span class="line">    ListNode* tail2=head2;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tail1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail1 = tail1-&gt;next;</span><br><span class="line">        len1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tail2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail2 = tail2-&gt;next;</span><br><span class="line">        len2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///若相交，尾节点肯定相同</span></span><br><span class="line">    <span class="keyword">if</span>(tail1 != tail2)</span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* node1=head1;</span><br><span class="line">    ListNode* node2=head2;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 找到两个链表等长的位置。</span></span><br><span class="line">    <span class="keyword">if</span>(len1&gt;len2)</span><br><span class="line">    &#123;</span><br><span class="line">        k=len1-len2;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">            node1=node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k=len2-len1;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">            node2=node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 两个链表未相交之前，节点肯定不同</span></span><br><span class="line">    <span class="keyword">while</span>(node1!=node2)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        node2=node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>给出一单链表头指针 head 和一节点指针 node ，O(1)时间复杂度删除节点 node</h5>
<p>对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode * head, ListNode * node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/// 边界值</span></span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        return ;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 把后面的节点值复制到本位置</span></span><br><span class="line">        node-&gt;data = node-&gt;next-&gt;data;</span><br><span class="line">        ListNode* temp = node-&gt;next;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 删除的是最后一个节点，只能用遍历法</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>( cur-&gt;next != node)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[特征选择-信息增益算法]]></title>
      <url>http://kinglanding.github.io/2014/04/21/2014-04-21-feature-selection--infomation-gain/</url>
      <content type="html"><![CDATA[<p><strong>信息增益</strong>：特征 $A$ 对于训练数据集$D$的信息增益 $g\left( D,A \right)$,定义为集合 $D$ 的经验熵 $H\left( D \right)$ 与特征 $A$ 在给定条件下 $D$
的经验条件熵c之差。</p>
<a id="more"></a>
<p>$$
g\left( D,A \right) =H\left( D \right) -H\left( { D }|{ A } \right)
$$</p>
<p>给定训练数据集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性，
而经验条件熵$H\left( { D }|{ A } \right)$表示在特征$A$给定条件下对数据集$D$分类的的不确定性。他们的差
就是<code>信息增益</code>。表示由于特征$A$而使得对数据集$D$的分类不确定性减少的程度。
显然，对于数据集$D$而言，信息增益依赖特征，不同的特征具有不同的信息增益，信息增益大的特征具有更强的分类能力。</p>
<p>所以算法选择特征的准则就是：对于训练数据集$D$，计算其每个特征的信息增益，并比较他们的大小，选在信息增益最大的特征。</p>
<p>设训练数据集为$$\left\vert  D  \right\vert $$表示样本大小，在我们这里就有42个实例。设有$K$个类$${C}<em>{k}$$。
令$$\left\vert {C}</em>{k}  \right\vert$$为属于类k的个数，即$$\sum_{k=1}^{K}{\left|{C}<em>{k} \right|}=\left|D \right|$$
设特征A有n个不同的取值， $$a_1, \ldots, a_n$$，根据特征$$A$$的取值将$$D$$划分为n个子集，$$D_1,D_2,\ldots,D_n$$,$$\left\vert D_i \right\vert$$
为$$D_i$$的样本个数，$$\sum</em>{i=1}^{n}\left\vert D_i \right\vert = \left\vert D \right\vert$$.记子集$$D_i$$中属于类$$C_k$$的样本的集合为$$D_ik$$,即
$$D_ik=D_i \cap C_k$$,$$|D_ik|$$为$$D_ik$$的样本个数。于是信息增益算法如下：</p>
<p><strong>信息增益算法</strong></p>
<p>输入：训练集D和特征A</p>
<p>输出：特征A对特征集D的信息增益$$g(D,A)$$</p>
<p>1.计算数据集$$D$$的经验熵$$H(D)$$</p>
<p>$$
H(D)=-\sum_{k=1}^{K}{\frac{\vert C_k \vert}{|D|}}\log_{2}{\frac{\vert C_k \vert}{|D|}}
$$</p>
<p>2.计算特征$$A$$对数据集$$D$$的经验条件熵H(D | A)</p>
<p>$$
H(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}}H(D_i)=-\sum_{i=1}^{n}{\frac{\vert D_i \vert}{|D|}} \sum_{k=1}^{K}{\frac{\vert D_{ik} \vert}{|D_i|}}\log_{2}{\frac{\vert D_{ik} \vert}{|D_i|}}
$$</p>
<p>3.计算信息增益</p>
<p>$$
g\left( D,A \right) =H\left( D \right) -H\left( { D }|{ A } \right)
$$</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[a scratch of feature selection in traffic classification]]></title>
      <url>http://kinglanding.github.io/2014/04/20/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/</url>
      <content type="html"><![CDATA[<p>特征选取在减轻识别流量监测方面起着很重要的作用。该方法可以显著提高计算流量分类的性能。但是，大部分的特征不能应用在实时在线的流量分类中（有些特征只能在获取完整个流量才能得到，比如传输的数据大小，流的传输时长等）。所以在抉择分类的时候，需要一个优化过的特征集合在更短的时间内完成流量的分类。另外一种方案就是使用新型的网络架构如SDN/OpenFlow在目前已有的特征选择方法中，Chi-squared, Fuzzy-rough and Consistency-based的特征选择方法最适合P2P流量选择（那现在的手机端流量分析怎么样？）这些算法在使用ML进行在线P2P检测时会给出较好的特征子集。</p>
<a id="more"></a>
<p>特征选取是寻找一个最小特征子集，可以快速有效的识别出实例的类别。如果利用一个特征进行分类聚类的结果与不使用它的结果没有很大的差别，则称整个特征时没有分类能力的。使用这些具备分类，聚类能力的特征，在分类的准确性和计算性能上都会得到提升。[1]主要研究的是在线流量分类中的流特征问题。然后考虑精度和性能的因素，选取了3中能够应用到P2P流量中的特征选择方法。</p>
<p>[1]实现的主要方法是使用了几个特征选择算法来提出在线的流量特征，使用J48算法作为分类器。</p>
<p>特征规模大小与分类器的效率和准确率息息相关，最优的特征集合可以减少分类器的建模和检测时间，从而提升分类器的性能[5]。主流的分类器有CSF, CON, Filter-Sub, Fuzzy-rough, Symmetrical-Uncert, Chi-squared,Info Gain, Relief, Principal and Latent-semantic。作者使用的Chi-squared, Consistency and fuzzy-rough算法，相关文献可以在论文[1]中找到。</p>
<h2>在线特征提取</h2>
<p>尽管Moore提出了248中流量特征，这些特征源自于同一个流中的报头信息。实际应用中的确不能全部都用到。具体操作是对现有的特征集使用那十个特征选择方法，分别选出各自的特征子集，然后应用到SVM分类器中，判别的准则为建模时间(训练时间)和准确率。然后合并准确率最高的前3个特征集合的并集作为最优特征子集。然后在分出那些特征可以在线获取（SOF-selection of features），他们作为分类器的输入-报文的特征向量。</p>
<p>核心思想是使用监督方法对有标记的数据集进行分类时，对特征集合进行规约，减少特征集的大小。</p>
<h3>使用信息熵增益算法对特征进行降纬</h3>
<p>实验前,<a href="http://www.aluenkinglee.com/blog/2014/04/21/feature-selection--infomation-gain/" target="_blank" rel="external">信息熵增益算法</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Instances:    42</span><br><span class="line">Attributes:   35</span><br><span class="line">              sip</span><br><span class="line">              sport</span><br><span class="line">              dip</span><br><span class="line">              dport</span><br><span class="line">              protocal</span><br><span class="line">              interval1</span><br><span class="line">              interval2</span><br><span class="line">              interval3</span><br><span class="line">              interval4</span><br><span class="line">              interval5</span><br><span class="line">              interval6</span><br><span class="line">              interval7</span><br><span class="line">              interval8</span><br><span class="line">              interval9</span><br><span class="line">              packet_len1</span><br><span class="line">              packet_len2</span><br><span class="line">              packet_len3</span><br><span class="line">              packet_len4</span><br><span class="line">              packet_len5</span><br><span class="line">              packet_len6</span><br><span class="line">              packet_len7</span><br><span class="line">              packet_len8</span><br><span class="line">              packet_len9</span><br><span class="line">              packet_len10</span><br><span class="line">              payload_len1</span><br><span class="line">              payload_len2</span><br><span class="line">              payload_len3</span><br><span class="line">              payload_len4</span><br><span class="line">              payload_len5</span><br><span class="line">              payload_len6</span><br><span class="line">              payload_len7</span><br><span class="line">              payload_len8</span><br><span class="line">              payload_len9</span><br><span class="line">              payload_len10</span><br><span class="line">              cluster</span><br></pre></td></tr></table></figure>
<p>得到的属性的排序是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Ranked attributes:</span><br><span class="line"> 1.944968503161257472   12 interval7</span><br><span class="line"> 1.79590506127720192    22 packet_len8</span><br><span class="line"> 1.789000161744105216    9 interval4</span><br><span class="line"> 1.485875203840541952   32 payload_len8</span><br><span class="line"> 1.476115354039271936   24 packet_len10</span><br><span class="line"> 1.474554148784290048   19 packet_len5</span><br><span class="line"> 1.433523944277332992   11 interval6</span><br><span class="line"> 1.4172094615274624     20 packet_len6</span><br><span class="line"> 1.40428856745235968     6 interval1</span><br><span class="line"> 1.326924790992714496   34 payload_len10</span><br><span class="line"> 1.181689898847241984   18 packet_len4</span><br><span class="line"> 1.105237515513706624   23 packet_len9</span><br><span class="line"> 1.009802257207393664   28 payload_len4</span><br><span class="line"> 1.000000000000000896   31 payload_len7</span><br><span class="line"> 1.000000000000000896   30 payload_len6</span><br><span class="line"> 0.993447238380203776   21 packet_len7</span><br><span class="line"> 0.868563607479333888    3 dip</span><br><span class="line"> 0.832352013234566144   14 interval9</span><br><span class="line"> 0.829607103088203904   29 payload_len5</span><br><span class="line"> 0.781988055469156096   17 packet_len3</span><br><span class="line"> 0.781988055469156096   16 packet_len2</span><br><span class="line"> 0.737113917996471168   10 interval5</span><br><span class="line"> 0.544053730963280448    2 sport</span><br><span class="line"> 0                      27 payload_len3</span><br><span class="line"> 0                       5 protocal</span><br><span class="line"> 0                       1 sip</span><br><span class="line"> 0                       4 dport</span><br><span class="line"> 0                      33 payload_len9</span><br><span class="line"> 0                      25 payload_len1</span><br><span class="line"> 0                      15 packet_len1</span><br><span class="line"> 0                      13 interval8</span><br><span class="line"> 0                       7 interval2</span><br><span class="line"> 0                      26 payload_len2</span><br><span class="line"> 0                       8 interval3</span><br></pre></td></tr></table></figure>
<p>所以对于属性payload_len3，protocal，sip，dport，payload_len9，payload_len1，payload_len2，packet_len1，interval8，interval2，interval3这十一个属性都可以去掉。
降维之后的属性集合大小为23.</p>
<p>降维之后的聚类结果</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/reduction2.png?raw=true" alt="降维之后的聚类结果" title="降维之后的聚类结果"></p>
<p>降维之前的聚类结果</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E8%B7%9D%E7%A6%BB.png?raw=true" alt="降维之前的聚类结果" title="降维之前的聚类结果"></p>
<p>效果非常吻合。</p>
<h3>使用PCA对特征集规约</h3>
<p>这个使用weka的来做的，做出来之后有12个特征（都是原有特征的线性组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Attributes:   12</span><br><span class="line">              0.333payload_len7+0.332packet_len7-0.307dip+0.295payload_len6+0.293packet_len6...</span><br><span class="line">              0.399packet_len8+0.398payload_len8-0.269payload_len5-0.268packet_len5+0.261interval5...</span><br><span class="line">              0.399interval4+0.309interval1-0.308packet_len10-0.274packet_len9-0.272payload_len9...</span><br><span class="line">              -0.366payload_len9-0.366packet_len9-0.349packet_len5-0.347payload_len5-0.288interval1...</span><br><span class="line">              -0.357interval3+0.351packet_len7+0.348payload_len7-0.324interval5+0.313interval7...</span><br><span class="line">              0.454interval6-0.424interval5-0.401interval1+0.262interval9+0.256packet_len4...</span><br><span class="line">              -0.402interval7-0.388payload_len6-0.387packet_len6-0.357interval8-0.26sport...</span><br><span class="line">              -0.597interval9+0.443packet_len10-0.427packet_len2-0.239packet_len3-0.209packet_len6...</span><br><span class="line">              0.865interval2+0.178interval3+0.168packet_len10+0.149packet_len4-0.146payload_len9...</span><br><span class="line">              -0.751sport+0.346interval3+0.286dip+0.216interval7-0.178packet_len2...</span><br><span class="line">              -0.434interval3+0.425interval2+0.315payload_len9+0.312packet_len9-0.311sport...</span><br></pre></td></tr></table></figure>
<p>降维之后的聚类结果</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/reduction1.png?raw=true" alt="降维之后的聚类结果" title="降维之后的聚类结果"></p>
<p>分析，由于降维特征减少太多，走势已经不太吻合。</p>
<h3>卡方分布提取特征算法</h3>
<p>对于这个算法，这里只给出特征选取的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Ranked attributes:</span><br><span class="line">157.0864   12 interval7</span><br><span class="line">145.6184   22 packet_len8</span><br><span class="line">130.1739   20 packet_len6</span><br><span class="line">123.7833    6 interval1</span><br><span class="line">123.0833    9 interval4</span><br><span class="line">118.16     32 payload_len8</span><br><span class="line">108.7528   34 payload_len10</span><br><span class="line">108.5061   24 packet_len10</span><br><span class="line">103.1333   18 packet_len4</span><br><span class="line"> 92.3818   11 interval6</span><br><span class="line"> 85.5423   23 packet_len9</span><br><span class="line"> 81.0409   19 packet_len5</span><br><span class="line"> 61.9733   28 payload_len4</span><br><span class="line"> 42        31 payload_len7</span><br><span class="line"> 42        29 payload_len5</span><br><span class="line"> 42        30 payload_len6</span><br><span class="line"> 42        21 packet_len7</span><br><span class="line"> 39.4135   16 packet_len2</span><br><span class="line"> 39.4135   17 packet_len3</span><br><span class="line"> 38.4      14 interval9</span><br><span class="line"> 37.9167    2 sport</span><br><span class="line"> 36.9542    3 dip</span><br><span class="line"> 33.9      10 interval5</span><br><span class="line">  0         5 protocal</span><br><span class="line">  0        33 payload_len9</span><br><span class="line">  0         4 dport</span><br><span class="line">  0         1 sip</span><br><span class="line">  0        25 payload_len1</span><br><span class="line">  0        15 packet_len1</span><br><span class="line">  0        13 interval8</span><br><span class="line">  0         8 interval3</span><br><span class="line">  0         7 interval2</span><br><span class="line">  0        26 payload_len2</span><br><span class="line">  0        27 payload_len3</span><br></pre></td></tr></table></figure>
<p>被取消的特征同样是那11个特征，只是排序结果不一样了。
所以理所当然kmeans实验室一致的。
Kmeans实验和实验1一样</p>
<p>最终选取的特征集合为23个</p>
<h2>参考</h2>
<p>[1]. Jamil, H.A., et al., Selection of On-line Features for Peer-to-Peer Network Traffic Classification, in Recent Advances in Intelligent Informatics. 2014, Springer. p. 379-390.</p>
<p>[2]. Zhen, L. and L. Qiong, A new feature selection method for internet traffic classification using ml. Physics Procedia, 2012. 33: p. 1338-1345.</p>
<p>[3]. Moore, A.W. and D. Zuev. Internet traffic classification using bayesian analysis techniques. in ACM SIGMETRICS Performance Evaluation Review. 2005: ACM.</p>
<p>[4]. Dash, M. and P.W. Koot, Feature selection for clustering, in Encyclopedia of database systems. 2009, Springer. p. 1119-1125.</p>
<p>[5]. 统计学习方法。李航</p>
<p>[6]. Mitra, P., C.A. Murthy and S.K. Pal, Unsupervised feature selection using feature similarity. IEEE transactions on pattern analysis and machine intelligence, 2002. 24(3): p. 301-312.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[“奇异”的内存覆盖]]></title>
      <url>http://kinglanding.github.io/2014/03/04/2014-03-04-qi-yi-de-nei-cun-fu-gai/</url>
      <content type="html"><![CDATA[<p>犯了一个愚蠢的问题，让我碰到了这么个内容错误的bug</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">*** glibc detected *** ./main: free(): invalid next size (fast): 0x0000000001dd8590 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x76d76)[0x7fd77419fd76]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(cfree+0x6c)[0x7fd7741a4aac]</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpcap.so.0.8(+0x1b470)[0x7fd774e2e470]</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libpcap.so.0.8(pcap_loop+0x2f)[0x7fd774e1fecf]</span><br><span class="line">./main[0x401869]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xfd)[0x7fd774147ead]</span><br><span class="line">./main[0x401001]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00402000 r-xp 00000000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main</span><br><span class="line">00602000-00603000 rw-p 00002000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main</span><br><span class="line">01dc8000-01de9000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fd770000000-7fd770021000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd770021000-7fd774000000 ---p 00000000 00:00 0 </span><br><span class="line">7fd774129000-7fd7742a9000 r-xp 00000000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so</span><br><span class="line">7fd7742a9000-7fd7744a9000 ---p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so</span><br><span class="line">7fd7744a9000-7fd7744ad000 r--p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so</span><br><span class="line">7fd7744ad000-7fd7744ae000 rw-p 00184000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so</span><br><span class="line">7fd7744ae000-7fd7744b3000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd7744b3000-7fd7744c8000 r-xp 00000000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fd7744c8000-7fd7746c8000 ---p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fd7746c8000-7fd7746c9000 rw-p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fd7746c9000-7fd77474a000 r-xp 00000000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so</span><br><span class="line">7fd77474a000-7fd774949000 ---p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so</span><br><span class="line">7fd774949000-7fd77494a000 r--p 00080000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so</span><br><span class="line">7fd77494a000-7fd77494b000 rw-p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so</span><br><span class="line">7fd77494b000-7fd774a33000 r-xp 00000000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17</span><br><span class="line">7fd774a33000-7fd774c33000 ---p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17</span><br><span class="line">7fd774c33000-7fd774c3b000 r--p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17</span><br><span class="line">7fd774c3b000-7fd774c3d000 rw-p 000f0000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17</span><br><span class="line">7fd774c3d000-7fd774c52000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd774c52000-7fd774c72000 r-xp 00000000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so</span><br><span class="line">7fd774e0e000-7fd774e13000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd774e13000-7fd774e4b000 r-xp 00000000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0</span><br><span class="line">7fd774e4b000-7fd774e4d000 r--p 00037000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0</span><br><span class="line">7fd774e4d000-7fd774e4e000 rw-p 00039000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0</span><br><span class="line">7fd774e4e000-7fd774e4f000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd774e6d000-7fd774e71000 rw-p 00000000 00:00 0 </span><br><span class="line">7fd774e71000-7fd774e72000 r--p 0001f000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so</span><br><span class="line">7fd774e72000-7fd774e73000 rw-p 00020000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so</span><br><span class="line">7fd774e73000-7fd774e74000 rw-p 00000000 00:00 0 </span><br><span class="line">7fff1591a000-7fff1593b000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff159ff000-7fff15a00000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">已放弃</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">对于这个问题，当时表示怎么会出现内存错误？我指针根本没有指错啊！那块内存也没有回收阿！！原来的程序比较大，所以我就抽象写了个简单的，慢慢找。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef class packet</span><br><span class="line">&#123;</span><br><span class="line">    private:</span><br><span class="line">    int len;</span><br><span class="line">    char* data;</span><br><span class="line">    public:</span><br><span class="line">    packet(int l,char * p)</span><br><span class="line">    &#123;</span><br><span class="line">	//注意这里，开始我写成了这样，一开始写顺了...</span><br><span class="line">	//我本意是想申请一个长度为l的连续内存区域。</span><br><span class="line">	//结果本意成为了申请了一个单位的内存，并给它赋值！！</span><br><span class="line">        data=new char(l);</span><br><span class="line">        //应该写成这样</span><br><span class="line">        //data=new char[l];</span><br><span class="line">        copy(p,p+l,data);</span><br><span class="line">        len = l;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    packet(const packet&amp; p)  </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len=p.len;</span><br><span class="line">        data=new char[len];</span><br><span class="line">        copy(p.data, p.data+len,data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    packet&amp; operator=(const packet&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len = p.len;</span><br><span class="line">        this-&gt;data = new char[this-&gt;len];</span><br><span class="line">        copy(p.data, p.data+len,this-&gt;data);</span><br><span class="line">        <span class="built_in">return</span> *this;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ~<span class="function"><span class="title">packet</span></span>()&#123;delete[] data;&#125;</span><br><span class="line">    char* <span class="function"><span class="title">get_data</span></span>()&#123;<span class="built_in">return</span> data;&#125;</span><br><span class="line"></span><br><span class="line">&#125;packet;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;packet&gt; stream;</span><br><span class="line">    char *t = <span class="string">"hello world.\n"</span>;</span><br><span class="line">    packet p(5,t);</span><br><span class="line">    cout &lt;&lt; p.get_data( )&lt;&lt; endl;</span><br><span class="line">    stream.push_back(p);</span><br><span class="line">    cout &lt;&lt; stream[0].get_data() &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行就会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cc -o main</span><br></pre></td></tr></table></figure>
<p>所以，上述的语句是没有申请够足够的内存(只申请了一个，却按照那个长度来copy！！当然会出现数据覆盖的错误，这个属于语言错误)，所以会造成之后的内存覆盖，导致出错。有意思的是在windows平台上，我试过，是不会提示你出错的。
不过确实可以看到运行过程中不合理的地方。比如数据被覆盖了overlapping!（实验平台debian 7 ，g++ (Debian 4.7.2-5) 4.7.2
windows是win7 + mingw）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** glibc detected *** ./main: double free or corruption (fasttop): 0x0000000000e55010 ***</span><br></pre></td></tr></table></figure>
<p>另外一点，在实际使用过程中，还是尽量不要混合使用malloc 和delete/delete[]</p>
<ul>
<li>
<p>使用malloc分配的内存尽量使用free释放掉</p>
</li>
<li>
<p>使用new分配的内存，看情况，若是对象类型本身就是数组类型，使用delete[],否则使用delete释放掉内存</p>
</li>
<li>
<p>使用new[]分配内存的，必须使用delete[] 来释放掉内存。否则只是释放掉了内存区域的第一个从而造成内存泄漏。</p>
</li>
</ul>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="http://stackoverflow.com/questions/18389313/glibc-detected-main-free-invalid-next-size-fast" target="_blank" rel="external">'** glibc detected *** ./main: free(): invalid next size (fast):'</a></li>
<li><a href="http://www.cplusplus.com/reference/cstring/memcpy/?kw=memcpy" target="_blank" rel="external">'好好使用memcpy'</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解TCP中的序列号和确认号]]></title>
      <url>http://kinglanding.github.io/2014/02/26/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/</url>
      <content type="html"><![CDATA[<p>之所以写这么一篇文章是因为被wireshark的序列号搞晕了，我不知道你们是否这样，当你读这篇article时，肯定你已经熟悉了TCP那个三次握手，
或者是SYN,SYN|ACK,ACK. 而我要做的也就是这个，提取一个流的前N个packets，针对目前的需求，只需要在传输层截取UDP和TCP的前多少个流即可。
所以我得分析网络层的这些协议底层到底是怎么回事，在结合libpcap完成流的提取任务。</p>
<p>相对来说TCP还是个复杂的协议，而且值得清楚的认识以下。那么结合wireshark和代码来认识下TCP里面的东西。</p>
<a id="more"></a>
<p><a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/traffic_parser/b.pcap?raw=true" title="pcap文件" target="_blank" rel="external">这里</a>是个已经准备好的pcap文件，本文结合这个文件对此进行描述。</p>
<p>这个文件分析的是微信在单一环境中的网络行为，所以比较简单。打开这个文件，找到开始的几个右键单击选择<code>Follow TCP Stream</code>，或者在filter那里输入<code>tcp.stream eq 1</code>可以看到这里。</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp1.png?raw=true" alt="Follow TCP Stream" title="Follow TCP Stream"></p>
<h4>三次握手</h4>
<p>TCP利用了8个标志位，在头部位置，以此来控制链接的状态，对我们最有用的就是SYN，ACK，FIN了。</p>
<ul>
<li>SYN - (Synchronize) Initiates a connection</li>
<li>FIN - (Final) Cleanly terminates a connection</li>
<li>ACK - Acknowledges received data</li>
</ul>
<p>下面将会看到，一个packet包含了多个flag set。</p>
<h6>对于这个流的第一个，注意Flags里面出了SYN位是1之外，其它都是0。</h6>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp2.png?raw=true" alt="第一次握手" title="第一次握手"></p>
<h6>接下来在看第二个，注意它有两个标志位被设置为1，分别是SYN和ACK。</h6>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp3.png?raw=true" alt="第二次握手" title="第二次握手"></p>
<h6>对于第三个packet，就只有ACK设置了。</h6>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp4.png?raw=true" alt="第三次握手" title="第三次握手"></p>
<p>这就是最初的TCP三次握手。</p>
<h4>序列号和应答号（SEQ和ACK）</h4>
<p>假设客户端为A，服务器为B，双方都为护着一个32bit的序列号，用来追踪传输了多少数据。。这个号包括了之前所传输的负载的
大小，由另一端的应答号来应答“你传的数据我都收到了。。”</p>
<p>当一个机器开始初始TCP序列号时，它是随机的！！不然会出现序列号攻击。。（我忘记了，在用那个wireshark后成功被它的相对序列号迷惑了==）,是一个0～ $2^{32}-1$的数。相对序列号是给人看的，所以像wireshark之辈使用它是为了人们方便阅读理解的。
（选择不启用相对序列号：选择<code>Edit &gt; Preferences...</code>不启用那个<code>Relative sequence numbers and window scaling</code>就可以了）</p>
<p>接下来让我们结合下图来看这个流的行为。在<code>Statistics &gt; Flow Graph...</code>选择<code>TCP flow</code>。</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp5.png?raw=true" alt="流图" title="流图"></p>
<p>这张图很容易理解就不说了。使用这张流图可以很方便的帮助我们理解他们是怎么工作的。</p>
<h6>packet #1</h6>
<p>A向B发了一个请求，我们可以在frame的tcp中分析出来，SYN=1而ACK=0，这意味这是一个流的起始包。这里使用的是相对序列号，所以为0.</p>
<h6>packet #2</h6>
<p>B收到了响应，恩，因为这是会话的开始，所以B这边也生成了一个随机的序列号，只不过在这里也显示为0了。SYN置为1。另外ACK也置为1，表明收到了A的响应。
(注意！虽然A没有发送任何负载payload，B仍然把ACK置为1，是因为收到的SYN或者FIN触发了这个增1行为。这儿不会涉及到任何负载长度的计算，因为带有这样信号的包不会携带负载的。)</p>
<h6>packet #3</h6>
<p>和#2一样，A回应了B的响应（SEQ=0，ACK=1）所以ACK为1.自己的SEQ因为收到的包中有SYN所以变为1。此时，双方的SEQ都是1，这种现象在所有TCP开始建立连接时候都是一样的。</p>
<h6>packet #4</h6>
<p>A这个包此时带有负载，这里的SEQ是1，因为上个包（#3）没有传输任何数据，ACK也是1，因为A没有传输任何数据。注意！packet的长度是341，但是我们计算的是传输层的数据长度--负载的长度，所以是ACK — LEN = LEN（#4）-LEN（#3） = 341 - 66 = 275。</p>
<h6>packet #5</h6>
<p>这个包是B（#5）对A（#4）发送数据的响应，此时B的ACK加上负载的长度是275变为276，表示我B收到了你A传输的数据payload（#4）. B此时的SEQ仍为1.</p>
<h6>packet #6</h6>
<p>这个包是B对A放送的HTTP响应，因为之前它（B）所有的包都没有负载，所以SEQ仍然为1，而ACK还是276.负载长度为627.</p>
<h6>packet #7</h6>
<p>好吧，这个例子有点特殊，到这里为止B的数据就发送完了。。。所以FIN置为1，表明你（A）要得我（B）都给完了，没我的事儿了，SEQ加上我发送的数据长度为628，你那边确认之后应该和我一样才对。ACK还是之前你给我发送的那些数据，还是这些276.</p>
<h6>packet #8</h6>
<p>A:收到了所有的数据，我先确认给你我数据我收到了，ACK加上627变为628。我之前发送的数据截止到目前是276，没错，我们对上了。</p>
<h6>packet #9</h6>
<p>A:既然我都要到了，那么我们就分手吧~~ 同意，FIN置为1，因为从B收到了带有FIN的报文（#7），所以ACK+1，变为629。因为上个数据包#8 没有发送任何数据，所以这里的SEQ不变,</p>
<h6>packet #10</h6>
<p>因为#9带有FIN，所以SEQ自增1.ACK不变。</p>
<p>关于代码，请看下篇。</p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li>
<p><a href="http://stackoverflow.com/questions/2672734/tcp-sequence-number-question" target="_blank" rel="external">TCP sequence number question</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="external">Transmission Control Protocol</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++的hashtable那些事]]></title>
      <url>http://kinglanding.github.io/2014/02/24/2014-02-24-c-plus-plus-de-hashtablena-xie-shi/</url>
      <content type="html"><![CDATA[<p>对于想知道hashtable原理的的人来说，多少对基本的数据结构和算法都有些了解，所以不再细说。</p>
<p>平常我们所说的一些容器来说，比如vector，list，stack之类，他们中的元素都是可以排序的，可以归为序列式容器，基于连续内存的vector可以实现随机存储，但是搜索的复杂度是O（n），list也是如此。
在关联式容器中，每个数据有一个键值和一个实值。元素插入到关联式容器中，容器内部结构根据其键值依据某个特定的规则将这个元素放置于适当的位置，从而实现插入和搜索是对数平均时间（基于红黑树），甚至是尽可能的是常数级别（就是这里说的散列表），其效率依赖于数据的特性和规则的设计。关联式的容器没有所谓的头尾，不会有begin(),end(),push_back()等这样的行为。</p>
<p>数组是个很好的内建数据结构，你甚至可以把数组看成一个最简单的hash表，index是种键值，而内容则是value。是不是很好，常数级寻址。但是也有问题，通常我们面对的键值不仅仅是简单的无符号的整数之流，还有很多的string啊，复杂的类对象啊，而这些问题就是hash函数所要处理的问题。hash函数把这个对象映射到[0-表的长度-1]之间。但是，不能够保证每个元素的键值与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。首先，为什么会出现冲突？基于这种想法设计出来的结构无疑是一种空间换时间的典范，尽管现在硬件越来越牛逼，但并不意味着可以随便挥霍，矛盾就出现在空间的数据往往小于我们要处理的数据规模，所以我们不可能设计出一种一一对应的函数来。而解决冲突就是hash第二个要解决的问题。</p>
<p>对于冲突的解决，往往有线性探测和二测探测以及开链法（类似list），前两种往往在数据规模小的情况下，即空间浪费的时候效率较高，这也意味着空间利用率不是很理想，而开链法，器负载系数大于1，就是索引的数组被极大利用了。</p>
<a id="more"></a>
<p>所以在hashtable中，把一个元素（对象）插入到其中，分为以下的过程：</p>
<p>1.得到元素的键值Key。</p>
<p>2.调用处理该键型KeyType的hash函数(有时候需要用户自己编写)得到hash值（即下标）。</p>
<p>3.把该元素存放到对应该下标的桶内。</p>
<p>查找，取值的过程:</p>
<p>1.得到元素的键值Key。</p>
<p>2.调用处理该键型KeyType的hash函数得到hash值（即下标）。</p>
<p>3.比较桶的内部元素是否与key相等（编写equal_to函数，基本类型意外用户根据需求编写），若都不相等，则没有找到。</p>
<p>4.取出相等的记录的value。</p>
<p>综上所述，实现一个hashtable必须注意hash函数 和 比较函数的接口提供。</p>
<h3>hashtable迭代器的设计</h3>
<p>首先明确我们的需求，定位有hash函数搞定，而找到该桶之后，只是需要顺着桶往下找就够了，所以迭代器是个前向迭代器，对应的接口有实值，键值，hash仿函数，提取仿函数，等于仿函数，还有空间配置器等。其他编写仿照一般的迭代器设计即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Key,</span><br><span class="line">         <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> ExtractKey,</span><br><span class="line">         <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">struct</span> __hashtable_iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; HashTable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key,</span><br><span class="line">            HashFcn, ExtractKey,</span><br><span class="line">            EqualKey, Alloc&gt;</span><br><span class="line">            iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;<span class="keyword">const</span> Value, Key,</span><br><span class="line">            HashFcn, ExtractKey,</span><br><span class="line">            EqualKey, Alloc&gt;</span><br><span class="line">            const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_nodes&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是前向移动，没有后退操作--</span></span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag    iterator_categor;</span><br><span class="line">    <span class="keyword">typedef</span> Value                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>               difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span>                  size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp;                  reference;</span><br><span class="line"></span><br><span class="line">    node* cur;</span><br><span class="line">    HashTable* ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    __hashtable_iterator(node* n, HashTable* tab) : cur(n), ht(tab) &#123;&#125;</span><br><span class="line">    __hashtable_iterator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*()  <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        return cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer   <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;(operator*());</span><br><span class="line">    &#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator  <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(const iterator&amp; it) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        return cur == it.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const iterator&amp; it) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        return cur != it.cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>详情请看<a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/stl/hashtable#L127" title="__hashtable_iterator" target="_blank" rel="external">__hashtable_iterator</a></p>
<h3>hashtable的数据结构</h3>
<p>由于采用开链的冲突解决方法，由此看来只需要一个vector代替桶，链表来装载桶内的元素即可。</p>
<p>需要注意的是hash函数，提取函数，等于函数的成员。另外需要buckets，还有元素数目的成员，有了这些基本就够了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashtable的数据结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Key,</span><br><span class="line">         <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> ExtractKey,</span><br><span class="line">         <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hashtable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> reference const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::const_iterator const_iterator;</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hashtable(size_type n,</span><br><span class="line">              <span class="keyword">const</span> HashFcn &amp;hf,</span><br><span class="line">              <span class="keyword">const</span> EqualKey &amp;eql,</span><br><span class="line">              <span class="keyword">const</span> ExtractKey &amp;ext)</span><br><span class="line">        :hash(hf),equals(eql),get_key(ext),num_elements(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        initialize_buckets(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashtable(size_type n,</span><br><span class="line">              <span class="keyword">const</span> HashFcn &amp;hf,</span><br><span class="line">              <span class="keyword">const</span> EqualKey &amp;eql)</span><br><span class="line">        :hash(hf),equals(eql),get_key(ExtractKey()),num_elements(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        initialize_buckets(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashtable(<span class="keyword">const</span> hashtable &amp;ht)</span><br><span class="line">        :hash(ht.hash),equals(ht.equals),get_key(ht.get_key),num_elements(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        copy_from(&amp;ht);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~hashtable()</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hashtable&amp; <span class="keyword">operator</span>= (const hashtable &amp;ht)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;ht != this)</span><br><span class="line">        &#123;</span><br><span class="line">            clear();</span><br><span class="line">            hash = ht.hash;</span><br><span class="line">            equals = ht.equals;</span><br><span class="line">            get_key = ht.get_key;</span><br><span class="line">            copy_from(&amp;ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hasher hash;</span><br><span class="line">    key_equal equals;</span><br><span class="line">    ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_nodes&lt;Value&gt; node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::vector&lt;node*, Alloc&gt; buckets;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; buckets;</span><br><span class="line">    size_type num_elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; getBuckets() &#123; return buckets;&#125;</span><br><span class="line">    <span class="comment">//返回bucket vector大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return buckets.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回bucket vector可能的最大值</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回元素个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到起始节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        size_type bucketIndex = <span class="number">0</span>;</span><br><span class="line">        node* first;</span><br><span class="line">        <span class="keyword">for</span> (first = buckets[bucketIndex];</span><br><span class="line">                !first &amp;&amp; ++bucketIndex &lt; buckets.size();</span><br><span class="line">                first = buckets[bucketIndex]) &#123;&#125;</span><br><span class="line">        return iterator(first, this);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素，不允许重复</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_unique(<span class="keyword">const</span> Value&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        resize(num_elements + <span class="number">1</span>);</span><br><span class="line">        return insert_unique_noresize(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素，允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> Value&amp; obj)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        resize(num_elements + <span class="number">1</span>);</span><br><span class="line">        return insert_equal_noresize(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某一键值的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        size_type bucketIndex = bkt_num_key(key);</span><br><span class="line">        node* first;</span><br><span class="line">        <span class="keyword">for</span> ( first = buckets[bucketIndex];</span><br><span class="line">                first &amp;&amp; !equals(get_key(first-&gt;val), key);</span><br><span class="line">                first = first-&gt;next) &#123;&#125;</span><br><span class="line">        return iterator(first, this);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断某一值出现的次数</span></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> size_type bucketIndex = bkt_num_key(key);</span><br><span class="line">        size_type result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> node* cur = buckets[bucketIndex];</span><br><span class="line">                cur;</span><br><span class="line">                cur = cur-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (equals(get_key(cur-&gt;val), key))</span><br><span class="line">                ++result;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断元素落在哪个bucket</span></span><br><span class="line">    <span class="comment">//提供两个版本</span></span><br><span class="line">    <span class="comment">//版本一：只接受实值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="keyword">const</span> Value&amp; obj)</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return bkt_num_key(get_key(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//版本二：接受实值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="keyword">const</span> Value&amp; obj,size_type n)</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return bkt_num_key(get_key(obj),n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回在index处的节点个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type bucketIndex)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        size_type n = <span class="number">0</span>;</span><br><span class="line">        node* tempNode = buckets[bucketIndex];</span><br><span class="line">        <span class="keyword">while</span>(tempNode &amp;&amp; ++n) tempNode = tempNode-&gt;next;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//整体删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//复制hash表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copy_from</span><span class="params">(<span class="keyword">const</span> hashtable&amp; ht)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//初始化buckets vector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> size_type n_buckets = next_size(n);</span><br><span class="line">        buckets.reserve(n_buckets);</span><br><span class="line">        buckets.insert(buckets.end(), n_buckets, (node*) <span class="number">0</span>);</span><br><span class="line">        num_elements = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点配置和释放函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="keyword">const</span> Value&amp; obj)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//node *tempNode = node_allocator::allocate();</span></span><br><span class="line">        node* tempNode = new node;</span><br><span class="line">        tempNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            construct(&amp;tempNode-&gt;val,obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//node_allocator::deallocate(tempNode);</span></span><br><span class="line">            <span class="keyword">delete</span> tempNode;</span><br><span class="line">            return <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return tempNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node *n)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        destroy(&amp;n-&gt;val);</span><br><span class="line">        <span class="keyword">delete</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最接近n并大于等于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span><span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return __get_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//版本一：只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return hash(key) % (buckets.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//版本二：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="keyword">const</span> Key&amp; key,size_type n)</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        return hash(key) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩充buckets vector，如有需要则进行扩充</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>;</span><br><span class="line">    <span class="comment">//在不需要重新分配bucket vector的情况下插入元素，元素不允许重复</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_unique_noresize(<span class="keyword">const</span> Value &amp;obj);</span><br><span class="line">    <span class="comment">//在不需要重新分配bucket vector的情况下插入元素，元素不允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="keyword">const</span> Value &amp;obj)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至于更多的请看代码（由于是简易实现的，配置器那块并没有使用stl的配置器，简单写了下）<a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/stl/hashtable#L127" title="hashtable" target="_blank" rel="external">hashtable</a></p>
<p>基于hashtable可以实现hash_set,hash_map,hash_multiset,hash_multimap,是这些容器的底层实现，而map,set,multiset,multimap则是基于rb-tree实现的，这是区别之一。</p>
<p>另外使用基于hashtable的时候需要提供hash仿函数，提取仿函数，等于仿函数这些参数。而基于rb-tree实现的需要比较函数即可。</p>
<p>平常时间根据查找速度, 数据量, 内存使用三个因素权衡，是否适合使用hashtable。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning :linear regression]]></title>
      <url>http://kinglanding.github.io/2014/01/05/2014-01-05-machine-learning-linear-regression/</url>
      <content type="html"><![CDATA[<p>机器学习中，总体来说是分为两类问题：</p>
<p>1.有监督的学习方法
2.无监督的学习方法</p>
<p>其他是这两者的综合，比如说半监督学习方法，强化学习（这个还未接触过）。</p>
<p>本文呢，先从有监督的学习方法开始讲起，主要是记载学习过程中个人认为最重要的地方。</p>
<p>对于监督学习中的两类问题，或者说三类吧，分别是：回归问题，分类问题和标注问题（tagging）。后面这个很有意思，不过在这里现说一下回归和分类的区别，假如我们要
做一个连续变量的预测，比如说房价的预测，或者明日气温的预测，都是属于回归问题；而对于离散变量的预测，比如判断一个病人是否得了癌症，良性还是恶心，则是一个明显的分
类问题。</p>
<p>接下来的文章，大概是对Andrew Ng视频的一个简单的总结，会结合变成实例（octave和C++）来插叙。</p>
<a id="more"></a>
<h3>线性回归</h3>
<p>好吧，先从一个简单的例子讲起，假设我们要为一个房子售价做个数学模型，价格和什么有关系？当然因素很多，比如房间的大小，离商业区的距离，嗯，房子几坪，奥，看起来不是
个简单事儿～，那好吧，遵循我们先从最简单做起的原则，现假设相同尺寸的房子价格和城市人口多少有关系，其他的先抛到一边去，我喜欢做甩手掌柜==
，你看这很合理！北京上海的房子价格能和三四线城市的比么=。=</p>
<p>那么好，我们会看到下面这个图！图先不上！！！假设你装了octave，并执行ex1的话就会看到它的！！</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f1.png?raw=true" alt="价格-人口关系图" title="价格-人口关系图"></p>
<p>在那之前，先让我们约定几个问题，恩恩：</p>
<h3>注释</h3>
<ul>
<li>$m$ ：是训练实例的个数</li>
<li>$x$ ：是输入的特征向量,很有可能是这样子：$x=(x_1,...,x_k)$</li>
<li>$y$ ：是输出结果</li>
<li>$(x,y)$ ：是一个训练实例</li>
<li>$(x^{(i)},y^{(i)})$ ：表示第i个训练样例</li>
</ul>
<p>好了，让我们接着开始吧。那我们应该如何表示我们的假设（hypothesis）呢？既然只有一个变量，这样表示好了：</p>
<p>$$
h_\theta(x) = \theta_0 + \theta_1x_1 ， \Theta={ (\theta_0,\theta_1) }
$$</p>
<p>那应该如何选择参数$\theta$呢？机器学习不就是干这活的么=。=</p>
<p>直观的感受就是：“嘿，干嘛不用LMS最小二乘法？无脑流，简单又实惠！统计课上的入门案例。。&quot;就他了。。。</p>
<p>所以，总结如下：</p>
<p>假设：</p>
<p>$$
h_\theta(x) = \theta_0 x_0 + \theta_1 x_1 ，
\Theta = \left( \begin{array}{c}
\theta_0 \
\theta_1
\end{array} \right),
x = (x_0,x_1),
x_0 \equiv 1 \
h_\theta(x) = x \cdot \Theta
$$</p>
<p>费用函数：</p>
<p>$$
J{(\Theta)}=\frac{1}{2m} \sum\limits_{i=1}^m \left(h_\theta(x^{(i)})-y^{(i)}
\right)^2
$$</p>
<p>目标：</p>
<p>$$
\min\limits_{\Theta} J{(\Theta)}
$$</p>
<p>回想下我们学过的数学知识吧，给定一个函数，求函数的最值，导数？梯度？那一套东西想起来了吧，OK。那好办了。要是还不是很清楚，那看一下[梯度](http://zh
.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6)以及[梯度下降法](http://zh.wikipedia.org/wiki/%
E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95)在此就不罗嗦了。Andrew
Ng在视频中讲的很形象，只要我们沿着山最陡的方向向下走，就会有可能找到最小值，翻译成数学语言就是沿着梯度相反的方向$- \nabla F(x)$,
就可以下降最快。（我们不是要找最小值么，当然是水往低处流！所以就是负值了）</p>
<h3>梯度下降法</h3>
<p>选定了回归模型，那就要确定参数$\Theta$了，$\Theta$只有在$J{(\Theta)}
$最小的情况下才能确定，所以问题归结为了求极小值的问题，梯度下降法是个不错的选择。当然，它会遇到找到的值只是个局部最小值。</p>
<p>这是示意图：</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f4.png?raw=true" alt="最小值"></p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f5.png?raw=true" alt="局部极小值"></p>
<p>流程如下：</p>
<ol>
<li>对$\Theta$赋予初始值，可随机，可为零向量。</li>
<li>同步改变$\Theta$值，使得$J{(\Theta)}$沿着梯度下降的方向走，直到学习曲线平滑，也就是收敛。</li>
</ol>
<p>用公式来描述就是,对于$j=1$和$j=0$，同时重复以下操作，直到$J{(\Theta)}$收敛。</p>
<p>$$
\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j}
J{(\theta_0,\theta_1) } \
\theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^m
\left(h_\theta(x^{(i)})-y^{(i)}
\right) \cdot x_j^{(i)}
$$</p>
<p>这是octave实现，向量形式,代码[详见](https://github.com/aluenkinglee/mlclass/blob/master/
mlclass-ex1/gradientDescent.m)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)</span><br><span class="line">%GRADIENTDESCENT Performs gradient descent to learn theta</span><br><span class="line">%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by </span><br><span class="line">%   taking num_iters gradient steps with learning rate alpha</span><br><span class="line"></span><br><span class="line">% Initialize some useful values</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line">J_history = zeros(num_iters, 1);</span><br><span class="line">for iter = 1:num_iters</span><br><span class="line">    %theta1 = theta(1) - alpha * X(:,1)&apos; *(X * theta - y) / m;</span><br><span class="line">    %theta2 = theta(2) - alpha * X(:,2)&apos; *(X * theta - y) / m;</span><br><span class="line">    %theta = [theta1; theta2]</span><br><span class="line">    theta = theta - alpha / m * (X&apos; * (X * theta - y));</span><br><span class="line">    % Save the cost J in every iteration    </span><br><span class="line">    J_history(iter) = computeCost(X, y, theta);</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>对应的C++实现，向量形式，代码[详见](https://github.com/aluenkinglee/mlclass/blob/master/mlclass
-ex1/gradientDescent.cpp)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"gradientDescent.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"computeCost.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mlclass::ex1;</span><br><span class="line"><span class="keyword">namespace</span> mlclass&#123;</span><br><span class="line"><span class="keyword">namespace</span> ex1&#123;</span><br><span class="line">    <span class="comment">//Performs gradient descent to learn theta</span></span><br><span class="line">    <span class="function">mat <span class="title">gradientDescent</span><span class="params">(mat X, vec y, mat&amp; theta, <span class="keyword">double</span> alpah,<span class="keyword">long</span> num_inters)</span></span>&#123;</span><br><span class="line">        <span class="comment">//number of training examples</span></span><br><span class="line">        <span class="keyword">long</span> m = y.n_rows;</span><br><span class="line">        </span><br><span class="line">        mat J_history = zeros&lt;mat&gt;(num_inters,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i &lt; num_inters; i++)&#123;</span><br><span class="line">            theta = theta - alpah/m* (X.t()* (X*theta - y));</span><br><span class="line">            J_history(i) = computeCost(X, y, theta);    </span><br><span class="line">        &#125;</span><br><span class="line">        return J_history;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有一个事情需要说明一下</strong></p>
<p>梯度下降发的收敛速度比较慢，相比于直接用公式求解$\theta$来说，尤其是当m较小的时候，比如说$m&lt;10000$,
这个时候用公式求解$\theta$比较快，但是大于这个值之后，计算矩阵的逆是花费较大的，此时使用梯度下降法比较理想，而且可以做到分布式计算值，加快求解速度。</p>
<p>$$
\Theta=(X^TX)^-1X^Ty
$$</p>
<p>关于线性回归就先到这，接下来会记述关于logistic回归等的文章。</p>
<blockquote>
<p>reference</p>
</blockquote>
<p>1.<a href="https://class.coursera.org/ml-004/lecture" target="_blank" rel="external">Machine Learning by Andrew Ng(1-2)</a></p>
<p>2.<a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">常用数学符号的 LaTeX 表示方法</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[可爱的Armadillo]]></title>
      <url>http://kinglanding.github.io/2013/12/31/2013-12-31-ke-ai-de-armadillo/</url>
      <content type="html"><![CDATA[<p>最近又重新看了一下coursera上的<a href="https://class.coursera.org/ml-004/lecture/index" target="_blank" rel="external">机器学习</a>(Andrew Ng讲的)，比起之前上老师的课和<a href="http://book.douban.com/subject/1102235/" title="机器学习" target="_blank" rel="external">机器学习</a>这本书来说，简直好太多。当初选修这个课程的时候明显感到编程实践环节太少，很不适应，只有一个大作业而已。好在这里的Quara和Programming Excises很给力。</p>
<p>我的设想是这样，octave作为一种快速验证想法的工具不适合应用在实际的生产环境中的，毕竟计算速度还是可以依靠集群和并行化来加快大数据处理。在此参考了C++的<a href="http://en.wikipedia.org/wiki/Comparison_of_linear_algebra_libraries" target="_blank" rel="external">线性代数库</a>之后选择了Armadillo,毕竟经常更新并且从官网资料来看，和octave代码相似便于移植，再说，从它本身和其他的对比来看，速度也是相当快的。</p>
<p>不过，在安装完Armadillo之后，编译example目录下的例子并不通过，提示</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp/cc9ckDKG.o: In function `void arma::gemv&lt;false, false, false&gt;::apply_blas_type&lt;double&gt;(double*, arma::Mat&lt;double&gt; const&amp;, double const*, double, double)&apos;:</span><br><span class="line">example1.cpp:(.text._ZN4arma4gemvILb0ELb0ELb0EE15apply_blas_typeIdEEvPT_RKNS_3MatIS3_EEPKS3_S3_S3_[_ZN4arma4gemvILb0ELb0ELb0EE15apply_blas_typeIdEEvPT_RKNS_3MatIS3_EEPKS3_S3_S3_]+0x7a): undefined reference to `wrapper_dgemv_&apos;</span><br><span class="line">/tmp/cc9ckDKG.o: In function `main&apos;:</span><br><span class="line">example1.cpp:(.text.startup+0x1a5d): undefined reference to `wrapper_ddot_&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>然后看了readme里面的编译链接部分，发现即使尝试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ example1.cpp -o example1 -O2 -llapack -lblas</span><br></pre></td></tr></table></figure>
<p>也是不行。所以不甘心的看了<code>/usr/include/armadillo_bits/config.hpp</code>，找到了<code>#define ARMA_USE_WRAPPER</code>,并把它注释掉,就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//// #define ARMA_USE_WRAPPER</span><br><span class="line">//// Comment out the above line if you&apos;re getting linking errors when compiling your programs,</span><br><span class="line">//// or if you prefer to directly link with LAPACK and/or BLAS.</span><br><span class="line">//// You will then need to link your programs directly with -llapack -lblas instead of -larmadillo</span><br></pre></td></tr></table></figure>
<p>在用上面的命令就可以了。</p>
<p>至于怎么安装，还是请看Readme吧各位。希望这个帖子能帮助有类似问题的人。（在debain系列的linux上有可能会有这样的问题。）</p>
<p>接下来，应该就会把之前看过的视频和资料的东西在整理一下，并借用这个库实现应该实现的部分。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[install nox on debian-bug fixed]]></title>
      <url>http://kinglanding.github.io/2013/11/13/2013-11-13-install-nox-on-debian-bug-fixed/</url>
      <content type="html"><![CDATA[<p>首先需要声明的一点是，到目前（2013/11）Nox在所有SDN控制器中不是最火的（相比Pox，floodlight），但是作为最先开发的一个SDN而言，还是有研究意义的。</p>
<a id="more"></a>
<h5>安装提示</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt/sources.list.d/</span><br><span class="line">sudo wget http://openflowswitch.org/downloads/debian/nox.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nox-dependencies</span><br><span class="line">sudo apt-get install libtbb-dev</span><br><span class="line">sudo apt-get install libboost-serialization-dev libboost-all-dev</span><br></pre></td></tr></table></figure>
<p>然后在你想放置Nox源码的地方做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/noxrepo/nox</span><br><span class="line">cd nox</span><br><span class="line">./boot.sh</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure</span><br><span class="line">make -j 5</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>很不幸，遇到了如下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">../../src/builtin/component.cc:414:1: required from here</span><br><span class="line">/usr/include/boost/property_tree/detail/json_parser_read.hpp:105:17: error:</span><br><span class="line">no matching function for call to ‘boost::property_tree::basic_ptree</span><br><span class="line">std::basic_string&lt;char, std::basic_string &gt;::push_back(std::pair</span><br><span class="line">std::basic_string&lt;char, std::basic_string &gt;)’</span><br><span class="line">/usr/include/boost/property_tree/detail/json_parser_read.hpp:105:17: note:</span><br><span class="line">candidate is:</span><br><span class="line">In file included from /usr/include/boost/property_tree/ptree.hpp:516:0,</span><br><span class="line">from ../../src/include/component.hh:35,</span><br><span class="line">from ../../src/builtin/component.cc:18:</span><br><span class="line">/usr/include/boost/property_tree/detail/ptree_implementation.hpp:362:9:</span><br><span class="line">note: boost::property_tree::basic_ptree::iterator</span><br><span class="line">boost::property_tree::basic_ptree::push_back(const value_type&amp;) [with Key =</span><br><span class="line">std::basic_string; Data = std::basic_string; KeyCompare = std::less</span><br><span class="line">std::basic_string&lt;char &gt;; boost::property_tree::basic_ptree::value_type =</span><br><span class="line">std::pair, boost::property_tree::basic_ptreestd::basic_string&lt;char,</span><br><span class="line">std::basic_string &gt; &gt;]</span><br><span class="line">/usr/include/boost/property_tree/detail/ptree_implementation.hpp:362:9:</span><br><span class="line">note: no known conversion for argument 1 from ‘std::pair</span><br><span class="line">std::basic_string&lt;char, std::basic_string &gt;’ to ‘const value_type&amp; &#123;aka</span><br><span class="line">const std::pair, boost::property_tree::basic_ptreestd::basic_string&lt;char,</span><br><span class="line">std::basic_string &gt; &gt;&amp;&#125;’</span><br><span class="line">make[4]: *** [nox_core-component.o] Error 1</span><br></pre></td></tr></table></figure>
<p>这个错误来源于nox依赖的boost库版本（1.49）的错误.注意错误原因是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/boost/property_tree/detail/json_parser_read.hpp:105</span><br><span class="line">error:</span><br><span class="line">no matching function for call to ‘boost::property_tree::basic_ptree</span><br><span class="line">std::basic_string&lt;char, std::basic_string &gt;::push_back(std::pair</span><br><span class="line">std::basic_string&lt;char, std::basic_string &gt;)’</span><br></pre></td></tr></table></figure>
<p>同样的问题点击<a href="http://lists.noxrepo.org/pipermail/nox-dev-noxrepo.org/2013-February/000668.html" title="[nox-dev] Nox build fails" target="_blank" rel="external">这里</a></p>
<p>解决方法：<code>/usr/include/boost/property_tree/detail/json_parser_read.hpp</code>找到这个文件。定位到<code>105行，</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.stack.back()-&gt;push_back(std::make_pair(c.name, Str(b, e)));</span><br></pre></td></tr></table></figure>
<p>换成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.stack.back()-&gt;push_back(std::make_pair(c.name, Ptree(Str(b, e))));</span><br></pre></td></tr></table></figure>
<p>重新make&amp;&amp; make install 即可。</p>
<h5>Reference</h5>
<ol>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6785" target="_blank" rel="external">read_json does not compile on GCC 4.7.0 with std=c++11</a></p>
</li>
<li>
<p><a href="http://lists.noxrepo.org/pipermail/nox-dev-noxrepo.org/2013-February/000668.html" target="_blank" rel="external">nox-dev Nox build fails</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在不同PC上协同写作同一个Octopress博客]]></title>
      <url>http://kinglanding.github.io/2013/11/13/2013-11-13-co-write-same-octopress-blog-on-different-pc/</url>
      <content type="html"><![CDATA[<p>因为需要在不同的地方写博客，在加上之前错误的操作，所以有了这篇文章。</p>
<p>假设已经学会了然后安装Octopress博客。</p>
<h2>Octopress 分支说明</h2>
<p>Octopress的git仓库(repository)有两个分支，分别是<code>master</code>和<code>source</code>，其中：</p>
<ol>
<li>
<p><code>master</code>存储的是博客网站本身，github基于此对页面渲染。该分支根目录处在<code>_deploy</code>文件夹，由<code>rake deploy</code>命令推送到服务器，一般而言，我们不需要对<code>master</code>做任何操作。</p>
</li>
<li>
<p><code>source</code>存储的是生成博客的源文件（各种markdown文件）,写作博客是在这个分支。每次写完之后，记得推送到服务器。这样就不用担心我们的备份了。</p>
</li>
</ol>
<a id="more"></a>
<h2>克隆服务器上的git到新机器</h2>
<p>将博客的源文件clone到本地的（假设就叫做）octopress文件夹内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b source git@github.com:username/username.github.com.git octopress</span><br></pre></td></tr></table></figure>
<p>接下来这步骤是最重要的，当初栽在这儿了。(会出现<code>No such file or directory - _deploy</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd octopress</span><br><span class="line">$ git clone -b master git@github.com:username/username.github.com.git _deploy</span><br></pre></td></tr></table></figure>
<p>还是要安装博客的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem install bundler</span><br><span class="line">$ rbenv rehash    		# If you use rbenv, rehash to be able to run the bundle command</span><br><span class="line">$ bundle install</span><br><span class="line">$ rake setup_github_pages	#执行初始化</span><br></pre></td></tr></table></figure>
<p>然后会提示输入仓库的ssh url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter the read/write url for your repository</span><br><span class="line">(For example, &apos;git@github.com:your_username/your_username.github.com)</span><br></pre></td></tr></table></figure>
<h2>Co-write 协同写作博客</h2>
<p>如果你是和别人合作博客，或者自己同时在好几个电脑上写博客，每次开始之前，git pull origin source获得最新的文件,rake generate生成新的页面.更新master并不是必须的，因为你更改源文件之后还是需要rake generate的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd octopress</span><br><span class="line">$ git pull origin source  	# update the local source branch</span><br><span class="line">$ cd ./_deploy</span><br><span class="line">$ git pull origin master  	# update the local master branch</span><br></pre></td></tr></table></figure>
<p>在source分支做了博客的发布，或者改变了博客的设置之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rake generate		 	#生成新的页面</span><br><span class="line"></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am &quot;Some comment here.&quot; </span><br><span class="line">$ git push origin source  	# 上面三行是更新远端source分支</span><br><span class="line"></span><br><span class="line">$ rake deploy             	# 更新远端master分支，文章就发布到了博客中</span><br></pre></td></tr></table></figure>
<h2>Reference</h2>
<ol>
<li>
<p><a href="http://williamherry.com/blog/2012/07/20/octopress-setup/" target="_blank" rel="external">Octopress - 像黑客一样写博客</a></p>
</li>
<li>
<p><a href="http://code.dblock.org/octopress-setting-up-a-blog-and-contributing-to-an-existing-one" target="_blank" rel="external">Setting up a Blog and Contributing to an Existing One</a></p>
</li>
<li>
<p><a href="http://boboshone.com/blog/2013/06/05/write-octopress-blog-on-multiple-machines/" target="_blank" rel="external">在多台电脑上写Octopress博客</a></p>
</li>
<li>
<p><a href="http://www.whispering.co/blog/2011/12/03/octopress-for-freshman/" target="_blank" rel="external">Octopress: 新手教程</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Use MathJax in Octopress to Write beautiful LaTex]]></title>
      <url>http://kinglanding.github.io/2013/11/13/2013-11-13-use-mathjax-in-octopress-to-write-beautiful-latex/</url>
      <content type="html"><![CDATA[<h4>首先看下$\LaTeX$的例子</h4>
<ul>
<li>块状的$\LaTeX$ 数学公式 (1)</li>
</ul>
<p>\begin{aligned}
w&amp;=ax^2+bxy+cy^2\<br>
&amp;=a(x+\frac{by}{2a})^2+(c-\dfrac{(by)^2}{4a})\<br>
&amp;=\frac{1}{4a}[4a^2(x+\frac{by}{2a})^2+(4ac-b^2)y^2]
\end{aligned}</p>
<p>\begin{aligned}
&amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
= \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \
&amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
\phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \
\vdots &amp; \ddots &amp; \vdots \
\phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
\end{array} \right)
\left( \begin{array}{c}
y_1 \
\vdots \
y_n
\end{array} \right)
\end{aligned}</p>
<a id="more"></a>
<ul>
<li>块状的$\LaTeX$ 数学公式 (2)</li>
</ul>
<p>另外一个例子<a href="http://en.wikipedia.org/wiki/Multivariate_normal_distribution" title="Multivariate normal distribution" target="_blank" rel="external">Multivariate normal distribution</a>:</p>
<p>$$
f_x(x_1,...,x_k)=\frac{1}{(2\pi)^{k/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))
$$</p>
<ul>
<li>内联$\LaTeX$ 数学公式 (3)</li>
</ul>
<p>在段内插入LaTeX代码： $\exp(-\frac{x^2}{2})$ 。</p>
<h4>$\LaTeX$ support</h4>
<p>为了能够使用MathJax对数学公式渲染，还是得使用几个步骤的。</p>
<ul>
<li>添加ramdown组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install kramdown</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>source/_includes/custom/head.html</code>这个文件，加入以下内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">MathJax.Hub.Register.StartupHook(&quot;TeX Jax Ready&quot;,function () &#123;</span><br><span class="line">          MathJax.InputJax.TeX.prefilterHooks.Add(function (data) &#123;</span><br><span class="line">                  data.math = data.math.replace(/^\s*&lt;!\[CDATA\[\s*((?:\n|.)*)\s*\]\]&gt;\s*$/m,&quot;$1&quot;);</span><br><span class="line">                    &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">  MathJax.Hub.Config(&#123;</span><br><span class="line">    tex2jax: &#123;</span><br><span class="line">      inlineMath: [ [&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;] ],</span><br><span class="line">      processEscapes: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">    MathJax.Hub.Config(&#123;</span><br><span class="line">      tex2jax: &#123;</span><br><span class="line">        skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;, &apos;code&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">    MathJax.Hub.Queue(function() &#123;</span><br><span class="line">        var all = MathJax.Hub.getAllJax(), i;</span><br><span class="line">        for(i=0; i &lt; all.length; i += 1) &#123;</span><br><span class="line">            all[i].SourceElement().parentNode.className += &apos; has-jax&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">   src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>修改_config.yml 文件 把markdown的渲染引擎从<code>rdiscount</code> 变为<code>kramdown</code></p>
</li>
<li>
<p>对于内联的$\LaTeX$ 数学公式，只需简单使用<code>$</code>...<code>$</code>即可。</p>
</li>
</ul>
<p>就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在段内插入LaTeX代码： $\exp(-\frac&#123;x^2&#125;&#123;2&#125;)$ 。</span><br></pre></td></tr></table></figure>
<ul>
<li>对于块状的$\LaTeX$ 数学公式，只需简单使用<code>$$</code>...<code>$$</code>即可。
就像这样：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f_x(x_1,...,x_k)=\frac&#123;1&#125;&#123;(2\pi)^&#123;k/2&#125;|\Sigma|^&#123;1/2&#125;&#125;exp(-\frac&#123;1&#125;&#123;2&#125;(x-\mu)^T\Sigma^&#123;-1&#125;(x-\mu))</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h4>Reference</h4>
<p><a href="http://kkx.github.io/blog/2012/05/05/zai-octopresszhong-shi-yong-latex/" title="在octopress中使用latex" target="_blank" rel="external">在octopress中使用latex</a></p>
<p><a href="http://kqueue.org/blog/2012/01/05/hello-world/" title="Hello world" target="_blank" rel="external">Hello world</a></p>
<p><a href="http://hungmingwu-blog.logdown.com/posts/14279-latex-on-octopress" title="在Octopress中使用Latex" target="_blank" rel="external">在Octopress中使用Latex</a></p>
<p><a href="http://yanping.me/cn/blog/2012/03/10/octopress-with-latex/" title="在Octopress中使用Latex" target="_blank" rel="external">在Octopress中使用Latex</a></p>
<p><a href="http://wowubuntu.com/markdown/#p" title="Markdown 语法说明 (简体中文版)" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a></p>
<p><a href="http://kramdown.gettalong.org/syntax.html#math-blocks" title="kramdown Syntax" target="_blank" rel="external">kramdown Syntax</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++前置声明和复制控制]]></title>
      <url>http://kinglanding.github.io/2013/10/24/2013-10-24-c-plus-plus-forward-declaration-and-copy-control/</url>
      <content type="html"><![CDATA[<p>突然有兴致想起了看会C++，因为最近一直是python，java，python的节奏...在这样下去，C++水平恐怕就停留在了只会编算法的地儿了...</p>
<p>随手一翻，看到了复制控制。对于这章，印象里的记忆是：</p>
<blockquote>
<blockquote>
<p>如果一个类它有形如指针或者申请了其他的系统资源成员，这个时候就得注意了，如申请资源，如何释放资源，复制的时候应该注意这些成员的行为是怎么样的。</p>
</blockquote>
</blockquote>
<p>然后，就不是很清楚了。大概看了看 其实也差不多...好吧是差很多。编程的过程中出现了一些问题。在这里记录下来&gt;.&lt; 真实忘不了了！</p>
<h5>复制构造函数</h5>
<p>它是一个特殊的构造函数，而且形参常用const Type&amp; 来修饰(如果凶残点，用指针也不是不行，但一定得是这两种！想想是为什么？)</p>
<a id="more"></a>
<p>有两种情况会调用它：</p>
<ol>
<li>定义一个新对象，并用一个同类型的对象对它初始化，就像这样 <code>string fileDesp(filename);</code>此处的filename是已经定义好的对象。'显示调用'</li>
<li>复制一个对象，并把它作为实参传给一个函数。'隐式调用'</li>
<li>从函数返回时复制一个对象。'隐式调用'</li>
<li>初始化顺序容器中的元素。'隐式调用'</li>
<li>根据元素初始化列表初始化数组元素。'隐式调用'</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> book = <span class="string">"ISBN-2323-23234"</span>;</span><br></pre></td></tr></table></figure>
<p>创建book对象时，编译器首先会接受一个C语言风格形参的string构造函数，创建一个临时对象，然后调用string的复制构造函数将book初始化那个临时对象的副本。（但是我感觉更像是'临时对象-&gt;赋值操作'..这里需要编码测试一下）</p>
<p>和java，python创建对象的方法来比,C++方法真心多...</p>
<h5>合成的复制构造函数</h5>
<p>就是自个没写编译器默认提供的复制构造函数，完成的功能很简单，数据成员逐个初始化，（<code>static</code>成员例外！！因为他们是属于类的！！）</p>
<h5>关于explicit的复制构造函数</h5>
<p>(以后加上，真心没写过，只知道IO类型的复制构造函数都是explicit的)</p>
<h5>赋值重载</h5>
<p>=是个二元运算符，所以有两个形参，分别对应左操作数和右操作数(const引用),当为成员函数时就是左操作数默认绑定到this指针上了。返回值为同一类型的引用。</p>
<h5>关于析构函数</h5>
<p>析构函数就是用来回收那些申请的系统资源的。所以自个度量何时该自己写给类的析构函数吧。</p>
<h5>关于何时调用析构函数</h5>
<ol>
<li>撤销类的对象自动调用</li>
<li>动态分配的对象只有在删除指向该指针时，才会运行析构函数！！否则会导致内存泄漏，小心啦。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename * p = new <span class="built_in">string</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>上述删除的行为不会销毁属于类的成员对象——static成员！其实挺好理解的啊。</p>
<p>下面是个例子。现在先在这里贴下代码，以后放到github里面去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//predeclaration of Message</span></span><br><span class="line"><span class="keyword">class</span> Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Folder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Folder()&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Folder"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Folder(<span class="keyword">const</span> Folder&amp;);</span><br><span class="line">    Folder&amp; <span class="keyword">operator</span>=(const Folder &amp;);</span><br><span class="line">    ~Folder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;Message*&gt; messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put_Folder_in_Message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Message*&gt;&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_Folder_from_Message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Message</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Message(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str=<span class="string">""</span>):</span><br><span class="line">        contents(str)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    Message(<span class="keyword">const</span> Message&amp;);</span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(const Message &amp;);</span><br><span class="line">    ~Message();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFldr</span><span class="params">(Folder*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remFldr</span><span class="params">(Folder*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> contents;</span><br><span class="line">    <span class="built_in">set</span>&lt;Folder*&gt; folders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put_Msg_in_Folders</span><span class="params">(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Folder*&gt;&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_Msg_from_Folders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Folder::Folder(<span class="keyword">const</span> Folder&amp; f):</span><br><span class="line">    messages(f.messages)</span><br><span class="line">&#123;</span><br><span class="line">    put_Folder_in_Message(messages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::put_Folder_in_Message(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Message*&gt; &amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;Message*&gt;::const_iterator beg = msg.begin();</span><br><span class="line">            beg != msg.end();</span><br><span class="line">            ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        (*beg)-&gt;addFldr(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder&amp; Folder::<span class="keyword">operator</span>=(const Folder &amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;f != this)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先把自己的给清除掉，在加上要赋值的，要不然肯定不一样。。</span></span><br><span class="line">        <span class="comment">//因为Messages不一样。。</span></span><br><span class="line">        remove_Folder_from_Message();</span><br><span class="line">        messages = f.messages;</span><br><span class="line">        put_Folder_in_Message(messages);</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::remove_Folder_from_Message()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;Message*&gt;::const_iterator beg = <span class="keyword">this</span>-&gt;messages.begin();</span><br><span class="line">            beg != messages.end();</span><br><span class="line">            ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        (*beg)-&gt;remFldr(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::~Folder()</span><br><span class="line">&#123;</span><br><span class="line">    remove_Folder_from_Message();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::save(Message &amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    addMsg(&amp;msg);</span><br><span class="line">    msg.addFldr(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::remove(Message&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    remMsg(&amp;msg);</span><br><span class="line">    msg.remFldr(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::addMsg(Message* msg)</span><br><span class="line">&#123;</span><br><span class="line">    messages.insert(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Folder::remMsg(Message* msg)</span><br><span class="line">&#123;</span><br><span class="line">    messages.erase(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy construction ,put the new message into the folders where the msg is pointed.</span></span><br><span class="line"><span class="keyword">inline</span> Message::Message(<span class="keyword">const</span> Message&amp; m):</span><br><span class="line">    contents(m.contents), folders(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">    put_Msg_in_Folders(folders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::put_Msg_in_Folders(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Folder*&gt; &amp;folders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;Folder*&gt;::const_iterator beg = folders.begin();</span><br><span class="line">            beg != folders.end();</span><br><span class="line">            ++ beg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//beg is a pointer to Folder*</span></span><br><span class="line">        (*beg)-&gt;addMsg(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Message&amp; Message::<span class="keyword">operator</span>=(const Message&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;msg != this) &#123;</span><br><span class="line">        <span class="comment">//首先把自己指向的那些folder都给取消掉</span></span><br><span class="line">        remove_Msg_from_Folders();</span><br><span class="line">        <span class="comment">//消息的内容copy过来</span></span><br><span class="line">        contents = msg.contents;</span><br><span class="line">        folders = msg.folders;</span><br><span class="line">        put_Msg_in_Folders(folders);</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::remove_Msg_from_Folders()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;Folder*&gt;::const_iterator beg = folders.begin();</span><br><span class="line">            beg != folders.end();</span><br><span class="line">            ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        (*beg)-&gt;remMsg(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Message::~Message()</span><br><span class="line">&#123;</span><br><span class="line">    remove_Msg_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::save(Folder&amp; folder)</span><br><span class="line">&#123;</span><br><span class="line">    addFldr(&amp;folder);</span><br><span class="line">    folder.addMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::addFldr(Folder* pfolder)</span><br><span class="line">&#123;</span><br><span class="line">    folders.insert(pfolder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::remove(Folder&amp; folder)</span><br><span class="line">&#123;</span><br><span class="line">    remFldr(&amp;folder);</span><br><span class="line">    folder.remMsg(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Message::remFldr(Folder* pfolder)</span><br><span class="line">&#123;</span><br><span class="line">    folders.erase(pfolder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">Message <span class="title">m</span><span class="params">(<span class="string">"dsfasdf"</span>)</span></span>;</span><br><span class="line">	Folder f = Folder();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"asdf"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以运行，但是不是想要的。</p>
<p>正确的应该分开写</p>
<p><code>Folder.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __Folder__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __Folder__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Message.h"</span></span></span><br><span class="line"><span class="comment">//predeclaration of Message</span></span><br><span class="line"><span class="keyword">class</span> Message;</span><br><span class="line"><span class="comment">// Message is a incomplete type.It can be used in limited ways only.</span></span><br><span class="line"><span class="comment">// 1.can not define object of this type.</span></span><br><span class="line"><span class="comment">// 2.only used as a pointer or ref.</span></span><br><span class="line"><span class="comment">// 3.declare it as the formal parameter of a function or return type of a function.</span></span><br><span class="line"><span class="keyword">class</span> Folder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Folder()&#123;&#125;</span><br><span class="line">    Folder(<span class="keyword">const</span> Folder&amp;);</span><br><span class="line">    Folder&amp; <span class="keyword">operator</span>=(const Folder&amp;);</span><br><span class="line">    ~Folder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Message is used as the formal parameter.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remMsg</span><span class="params">(Message*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Message is used as the typename of the template.</span></span><br><span class="line">    <span class="built_in">set</span>&lt;Message*&gt; messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put_Folder_in_Message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Message*&gt;&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_Folder_from_Message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Message.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __Message__</span><br><span class="line">#define __Message__</span><br><span class="line"></span><br><span class="line">using std::string;</span><br><span class="line">using std::set;</span><br><span class="line"></span><br><span class="line">#include &quot;Folder.h&quot;</span><br><span class="line">//predeclaration of Folder</span><br><span class="line">class Folder;</span><br><span class="line">// Folder is a incomplete type.It only can be used in limited ways.</span><br><span class="line">// 1.can not define object of this type.</span><br><span class="line">// 2.only used as a pointer or ref.</span><br><span class="line">// 3.declare it as the formal parameter of a function or return type of a function.</span><br><span class="line"></span><br><span class="line">class Message</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Message(const string &amp; str=&quot;&quot;):</span><br><span class="line">        contents(str) &#123;&#125;</span><br><span class="line">    Message(const Message&amp;);</span><br><span class="line">    Message&amp; operator=(const Message &amp;);</span><br><span class="line">    ~Message();</span><br><span class="line"></span><br><span class="line">    // Folder is used as the formal parameter.</span><br><span class="line">    void save(Folder&amp;);</span><br><span class="line">    void remove(Folder&amp;);</span><br><span class="line">    void addFldr(Folder*);</span><br><span class="line">    void remFldr(Folder*);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string contents;</span><br><span class="line">    set&lt;Folder*&gt; folders;</span><br><span class="line"></span><br><span class="line">    // Folder is used as the typename of the template.</span><br><span class="line">    void put_Msg_in_Folders(const set&lt;Folder*&gt;&amp;);</span><br><span class="line">    void remove_Msg_from_Folders();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>一个简单的例子，就是来测试一下<code>class A=B</code>时究竟会不会同时调用赋值构造函数和拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    object(<span class="keyword">int</span> d = <span class="number">0</span>):</span><br><span class="line">        data(d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    object(<span class="keyword">const</span> object&amp; other):</span><br><span class="line">        data(other.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    object&amp; <span class="keyword">operator</span>=(const object&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;other != this)</span><br><span class="line">        &#123;</span><br><span class="line">            data = other.data;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment constructor"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">behavior1</span><span class="params">(object other)</span>	<span class="comment">//形参调用copy constructor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test behavior1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">behavior2</span><span class="params">(object&amp; other)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test behavior2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    object A;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">object <span class="title">B</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    object C = A;  <span class="comment">//这个情况仍然只是调用copy constructor</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    C=B;	   <span class="comment">//只有这种情况下才会调用assignment constructor</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    behavior1(A);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    behavior2(A);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">default constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line"></span><br><span class="line">assignment constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">test behavior1</span><br><span class="line"></span><br><span class="line">test behavior2</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[virtualbox网络环境和登录]]></title>
      <url>http://kinglanding.github.io/2013/10/20/2013-10-20-virtualbox-network-environment-and-login/</url>
      <content type="html"><![CDATA[<p>最近由于实验室需要研究SDN的一些东西，再此先来搭配下环境。
对于虚拟机的一些选择，可以看这里:
<a href="http://mininet.org/vm-setup-notes/" target="_blank" rel="external">vm-setup-notes</a>
我这里的环境是:</p>
<p><code>os: debian 7(wheezy) 64bit</code></p>
<p><code>xwindows: kde</code></p>
<p><code>VM： virtualbox</code></p>
<p><code>controller: pox</code></p>
<a id="more"></a>
<p>按照上述的网址，可以比较容易的搭配出来需要的环境，下面就说以下之后遇到的问题。</p>
<ul>
<li>virtualbox的鼠标独占问题，只是提示太不明明显了！对于那个right ctrl的提示我郁闷了好一会，我以为是鼠标右键+ctrl...其实是右边的ctrl键。对于这个键的设定，你可以从“管理”&gt;“全局设定”&gt;&quot;热键&quot;来设置你喜欢的按键..我就吐槽这么一句，之前vmware对此的说明很明了！</li>
<li>Using Host-only adapter to SSH guest from host.</li>
</ul>
<h3>NAT模式</h3>
<p>特点：</p>
<ol>
<li>如果主机可以上网，虚拟机可以上网</li>
<li>虚拟机之间不能ping通</li>
<li>虚拟机可以ping通主机（此时ping虚拟机的网关，即是ping主机）</li>
<li>主机不能ping通虚拟机</li>
</ol>
<p>但是这个情况下是不能满足我的使用条件...我需要在host登录到guest中，so pass</p>
<h3>桥接模式</h3>
<p>特点：</p>
<ol>
<li>如果主机可以上网，虚拟机可以上网</li>
<li>虚拟机之间可以ping通</li>
<li>虚拟机可以ping通主机</li>
<li>主机可以ping通虚拟机 (以上各点基于一个前提：主机可以上网)</li>
<li>如果主机不可以上网，所有1-4特点均无</li>
</ol>
<p>这个挺好，觉得可以满足我的要求但是，发现它的IP地址要求是自动非配的，我们实验室的IP是校园内网固定IP...</p>
<h3>Host-only Adapter模式</h3>
<p>特点：</p>
<ol>
<li>虚拟机<code>不</code>可以上网</li>
<li>虚拟机之间可以ping通</li>
<li>虚拟机可以ping通主机（注意虚拟机与主机通信是通过主机的名为VirtualBox Host-Only Network的网卡，因此ip
是该网卡ip <code>192.168.56.1</code>，而不是你现在正在上网所用的ip）</li>
<li>主机可以ping通虚拟机</li>
</ol>
<p>应用场景：
需要搭建一个模拟局域网，所有机器可以互访。（颇不得以选这个的..）</p>
<p>ip样式：<code>netstat -rn</code>查看路由表
ip 与本机VirtualBox Host-Only Network的网卡ip在同一网段内（默认192.168.56.*）
网关 本机VirtualBox Host-Only Network的网卡ip（默认192.168.56.1）</p>
<h3>登录虚拟机</h3>
<p>登录虚拟机，首先开开virtualbox的虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mininet-vm login: mininet</span><br><span class="line">Password: mininet</span><br></pre></td></tr></table></figure>
<p>接下来查看我们的vm地址：（在guest里面操作）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig</span><br></pre></td></tr></table></figure>
<p>例如我这里的ip地址是<code>192.168.56.101</code>,然后就使用我们可爱的SSH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -Y mininet@192.168.56.101</span><br></pre></td></tr></table></figure>
<p>输入密码就可以了</p>
<p>当然上面的不好看，做下别名好了。（在我们host里面操作）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/hosts</span><br><span class="line">192.168.56.101 mininet-vm</span><br></pre></td></tr></table></figure>
<p>保存即可，这样子就可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -Y mininet@mininet-vm</span><br></pre></td></tr></table></figure>
<p>接下来就可以去玩下面的实验了^^</p>
<blockquote>
<p>参考文档:</p>
</blockquote>
<blockquote>
<p><a href="http://blog.csdn.net/yxc135/article/details/8458939" target="_blank" rel="external">VirtualBox虚拟机网络环境解析</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.live-in.org/archives/832.html" target="_blank" rel="external">ssh命令用于远程登录上Linux主机</a></p>
</blockquote>
<blockquote>
<p><a href="http://mininet.org/vm-setup-notes/" target="_blank" rel="external">SSH into VM</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySql交换两列]]></title>
      <url>http://kinglanding.github.io/2013/06/14/2013-06-14-mysqljiao-huan-liang-lie/</url>
      <content type="html"><![CDATA[<p>事情的起因是这个发现数据库中出现了某两列数据正好颠倒了，大部分数据都是正常的，
这些错误的原因是数据源有问题，今天在进一步的做标签聚类的时候分析的时候发现这
些占很小比例的误差，辛亏发现了，否则做出来的结果有可能会郁闷很久。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,place_lat,place_lon from `nearbyinfo` where `nearbyinfo`.`place_lat`&gt;0;</span><br></pre></td></tr></table></figure>
<p>正常的数据都是&lt; <code>39.xxx</code>, <code>160.2xxx</code> &gt;之间，如图所示:</p>
<a id="more"></a>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/11.png?raw=true" alt="正常数据" title="正常数据"></p>
<p>但是幸好及时发现了存在这样的数据，</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="异常数据" title="异常数据"></p>
<p>一开始想的是想写sql语句试着把这两栏的数据给交换过来，可是sql太渣…然后就想着找
到这些ID和他们的坐标值（都已经出来了），然后用python读出来写成update的语句，
然后在执行一下就可以了，这也太…</p>
<p>辛亏最终还是找到了，在这还是完整的说明一下吧。首先创建一个表，在Mysql中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE  IF NOT EXISTS `weibodata` </span><br><span class="line">USE `weibodata`;</span><br><span class="line">DROP TABLE IF EXISTS `test`;</span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` varchar(45) DEFAULT NULL,</span><br><span class="line">  `b` varchar(45) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line">LOCK TABLES `test` WRITE;</span><br><span class="line">INSERT INTO `test` VALUES (1,&apos;-1&apos;,&apos;4&apos;),(2,&apos;3&apos;,&apos;2&apos;);</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
<p>所以看起来会是这个样子:</p>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="交换之前" title="交换之前"></p>
<p>然后执行下面的语句，会发生第二行swap了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test t1,test t2 SET t1.a=t1.b,t2.b=t2.a where t1.id =t2.id and t1.a&gt;0;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="交换之后" title="交换之后"></p>
<p>在尝试一下就会变成原样。</p>
<p>问题解决了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,place_lat,place_lon from nearbyinfo where place_lat &gt;100;</span><br><span class="line">UPDATE nearbyinfo t1,nearbyinfo t2 SET t1.place_lat=t1.place_lon,t2.place_lon=t2.place_lat where t1.id = t2.id and t1.place_lat&gt;100;</span><br><span class="line">select id,place_lat,place_lon from nearbyinfo where id in (1025,4974,4814,2685);</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[近期总结]]></title>
      <url>http://kinglanding.github.io/2013/04/17/2014-03-14-jin-qi-zong-jie/</url>
      <content type="html"><![CDATA[<p>一直以来对数据挖掘，推荐的算法比较感兴趣，可是大家也都知道如果只是看课本上的那些理论性的公式和说辞会给人一种很空泛的感觉，所以个人感觉迫切需要做这方面的实践。可惜做这些的最最最遗憾缺少的就是数据的问题。所以我的给自己整点数据。</p>
<p>还好这学期算是有时间，相对于上个学期一周n多的课程和大作业来说算是幸福多的了。（而且那个时候还要给师兄们各种帮忙，要写android程序版本中的几个activity，呵呵，不过很有意思，师兄有一个是做LBS信息匿名处理服务的，挺有意思，对比微博，人人中的定位&gt;.&lt;就会发现这个很有必要的，获取一个人的坐标信息还是很容易的。）所以就琢磨这弄点数据自己来搞，一开始我是想获得微博的数据，具体来说是获得某个人过去说过的话，然后分析什么样的人，什么样的性格，心理怎么样。（我认为计算机和其他学科的交叉才是王道，说到底，计算机，算法毕竟只是一种计算的工具和技术，和其他学科（比如地理，心理学，生物学）的交叉才会有更多新的发现，现在数据量都很多，人工时处理不了的。机器学习和数据挖掘的应用领域啦~）</p>
<a id="more"></a>
<p>不过跟老板交涉的结果是，嗯，想法是不错，可惜缺少可以定量分析心理学的依据，毕竟你不是研究过心理学的，没有话语权,论文不好发，没个几年时间你不好毕业&gt;&lt;。。好吧，从此我就踏上了LBSNs的不归路，呵呵。话说虽然Foursquare现在半死不活的，但是我个人认为不是LBS的不成功，而是Foursquare本省商业模式的问题，这个得专门写一篇文章，不在这里跑题了。</p>
<p>在LBSN中除了可以分析用户的行为轨迹，感觉这里面没有可以继续深入的了，因为在继续做下去就是匿名，而且很多人都已经做过了。基于地理位置上的数据挖掘和推荐貌似还不是很多(资料查的少的缘故，不敢妄下定论)。</p>
<p>通过新浪微博API调用获取地理位置信息</p>
<h5>目的</h5>
<p>获取带地理标签的微博数据，为以后分析数据使用。</p>
<h5>相关工作</h5>
<p><code>目前获取微博信息的方法有两种</code></p>
<ol>
<li>
<p>编写网络爬虫抓取带地理标签的微博</p>
</li>
<li>
<p>通过OAuth2.0认证使用微博提供的API获取微博</p>
</li>
</ol>
<p><code>网络爬虫的基本工作流程如下</code></p>
<ol>
<li>
<p>首先选取一部分精心挑选的种子URL；</p>
</li>
<li>
<p>将这些URL放入待抓取URL队列；</p>
</li>
<li>
<p>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p>
</li>
<li>
<p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p>
</li>
</ol>
<p><code>抓取策略</code></p>
<p>在爬虫系统中，待抓取URL队列是很重要的一部分。待抓取URL队列中的URL以什么样的顺序排列也是一个很重要的问题，因为这涉及到先抓取那个页面，后抓取哪个页面。而决定这些URL排列顺序的方法，叫做抓取策略。下面重点介绍几种常见的抓取策略：</p>
<ul>
<li>
<p>深度优先遍历策略</p>
</li>
<li>
<p>宽度优先遍历策略</p>
</li>
<li>
<p>反向链接数策略</p>
</li>
<li>
<p>Partial PageRank策略</p>
</li>
</ul>
<p>可是在使用这种方法的过程中，发现了微博在使用cookie登陆的过程中有个加密的处理，这个加密算法一时没有弄明白，我不知道具体的加密步骤所以也反解不出来。所以就使用了另外的方法。</p>
<p><code>使用OAuth2.0认证</code></p>
<p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p>
<p>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p>
<h5>认证和授权过程</h5>
<p><code>在认证和授权的过程中涉及的三方包括</code></p>
<ol>
<li>
<p>服务提供方，用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。</p>
</li>
<li>
<p>用户 ，存放在服务提供方的受保护的资源的拥有者。</p>
</li>
<li>
<p>客户端 ，要访问服务提供方资源的第三方应用。在认证过程之前，客户端要向服务提供者申请客户端标识。</p>
</li>
</ol>
<p><code>使用OAuth进行认证和授权的过程如下所示</code></p>
<ol>
<li>用户访问客户端的网站，想操作自己存放在服务提供方的资源。</li>
<li>客户端向服务提供方请求一个临时令牌。</li>
<li>服务提供方验证客户端的身份后，授予一个临时令牌。</li>
<li>客户端获得临时令牌后，将用户引导至服务提供方的授权页面请求用户授权。在这个过程中将临时令牌和客户端的回调连接发送给服务提供方。</li>
<li>用户在服务提供方的网页上输入用户名和密码，然后授权该客户端访问所请求的资源。</li>
<li>授权成功后，服务提供方引导用户返回客户端的网页。</li>
<li>客户端根据临时令牌从服务提供方那里获取访问令牌 。</li>
<li>服务提供方根据临时令牌和用户的授权情况授予客户端访问令牌。</li>
<li>客户端使用获取的访问令牌访问存放在服务提供方上的受保护的资源</li>
</ol>
<h5>方法</h5>
<p>前期比较了两种方案，决定优先使用网路爬虫的方案。</p>
<p>在使用爬虫的方案时，尽管在使用cookie模拟登陆renren.com，douban.com可以成功，但还是在weibo.com这遇到了另外一个头痛加密数据的问题，之前的工作没有办法得到应用。而且短时间内数据加密的方式解决不了。放弃。</p>
<p>使用OAuth认证调用微博API的方案可以很方便的通过认证并且得到带有地理位置标签的数据。目前获得了35000条微博的数据。</p>
<p>对其返回的数据分析发现，该数据结构足以满足需求，用户id，发布微博时间，发布地点，微博文本内容等。</p>
<p>这些数据的来源是源自微博中周边微博这类地理位置的API。出于实验的目的，我把海淀区划分了15个区域，取区域内的标志性地点的经纬度（可以随时增加其他点），再以一个较低的频率（为了尽量避免取到重复数据）去取这15个点的周边微博（全部含有地理标签）。</p>
<p>对于这些数据的想法，目前是把这些数据标示在地图上，先得到直观上的点的分布，再分析为什么会再此聚集，和什么属性相关。这是基本的想法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python处理带有时区的的字符串]]></title>
      <url>http://kinglanding.github.io/2013/04/16/2013-04-16-pythonchu-li-dai-you-shi-qu-de-de-zi-fu-chuan/</url>
      <content type="html"><![CDATA[<p>最近在处理一些微博的数据，其中从服务器返回来的json串最后转换成了python中的字典，
只是可惜时间也被变成了字符串格式，好在python文档足够全且简单，可以使用datetime
中的strptime来解决，尽管如此还是在时区那卡了会</p>
<p>微博返回的时间数据格式如下：</p>
<h5>“Fri Aug 12 14:09:31 +0800 2011″</h5>
<p>然后我这样处理的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strptime(&apos;Fri Aug 12 14:09:31 +0800 2011&apos;, &apos;%a %b %d %H:%M:%S %z %Y&apos;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当然也可以这样，只是试验下而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt2 = datetime.strptime(&apos;Fri Aug 12 14:09:31 +0800 2011&apos;, &apos;%a %b %d %H:%M:%S %Z %Y&apos;)</span><br></pre></td></tr></table></figure>
<p>然而却出现了如下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: time data &apos;Fri Aug 12 14:09:31 +0800 2011&apos; does not match format &apos;%a %b %d %H:%M:%S %Z %Y&apos;</span><br></pre></td></tr></table></figure>
<p>查了下<a href="http://stackoverflow.com/questions/10540399/strftime-does-not-return-abbreviated-time-zone" target="_blank" rel="external">资料</a>
发现这个跟系统有关系，而且这个是bug，（虽然开发者不承认，但是我觉得还有有点关系….虽然它又跟locals有关系。。。识别起来
确实很繁琐）比如现在我是在windows上处理的结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print time.strftime(&quot;%a, %d %b %Y %I:%M:%S %p %Z&quot;, time.localtime(10.5))</span><br><span class="line">Thu, 01 Jan 1970 08:00:10 AM 中国标准时间</span><br><span class="line">&gt;&gt;&gt; print time.strftime(&quot;%a, %d %b %Y %I:%M %p %Z&quot;, time.gmtime())</span><br><span class="line">Tue, 16 Apr 2013 08:33 AM 中国标准时间</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>和那个+8000格格不入，好吧 反正数据的处理设计不到时区，那么可以这样子做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dt2 = datetime.strptime(&apos;Fri Aug 12 14:09:31 +0800 2011&apos;, &apos;%a %b %d %H:%M:%S +0800 %Y&apos;)</span><br><span class="line">&gt;&gt;&gt; print dt2</span><br><span class="line">2011-08-12 14:09:31</span><br></pre></td></tr></table></figure>
<p>对现在的需求来说,反而更好.</p>
<h3>参考</h3>
<ol>
<li>
<p><a href="http://bugs.python.org/issue6641" target="_blank" rel="external">issue6641</a></p>
</li>
<li>
<p><a href="http://stackoverflow.com/questions/4788533/python-strftime-gmtime-not-respecting-timezone" target="_blank" rel="external">python-strftime-gmtime-not-respecting-timezone</a></p>
</li>
<li>
<p><a href="http://stackoverflow.com/questions/10540399/strftime-does-not-return-abbreviated-time-zone" target="_blank" rel="external">strftime-does-not-return-abbreviated-time-zone</a></p>
</li>
<li>
<p><a href="http://forum.open.weibo.com/read.php?tid=11780" target="_blank" rel="external">微博使用</a></p>
</li>
<li>
<p><a href="http://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior" target="_blank" rel="external">strftime-and-strptime-behavior</a></p>
</li>
<li>
<p><a href="http://stackoverflow.com/questions/466345/converting-string-into-datetime" target="_blank" rel="external">converting-string-into-datetime</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python中关于变量属性的迷惑]]></title>
      <url>http://kinglanding.github.io/2013/03/15/2013-03-15-puzzles-of-vars-properties-in-python/</url>
      <content type="html"><![CDATA[<p>当初使用C++，java的时候，变量的属性（可访问性，scope这类的意思）如public，private，protected，static这类很好理解。</p>
<p>但是Python中默认的成员函数，成员变量都是公开的(public),而且python中没有类似public,private等关键词来修饰成员函数，成员变量。</p>
<a id="more"></a>
<p>在python中定义私有变量只需要在变量名或函数名前加上 ”__“两个下划线，那么这个函数或变量就会为私有的了。对static这样的很是好奇。</p>
<p>于是便有了这样子的实验。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">o1 = A()</span><br><span class="line">o2 = A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> A,o1,o2</span><br><span class="line"><span class="keyword">print</span> A.value,o1.value,o2.value</span><br><span class="line"></span><br><span class="line">o1.value += <span class="number">10</span></span><br><span class="line"><span class="keyword">print</span> A.value,o1.value,o2.value</span><br><span class="line"></span><br><span class="line">A.value += <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> A.value,o1.value,o2.value</span><br><span class="line"></span><br><span class="line">o2.value += <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> A.value,o1.value,o2.value</span><br></pre></td></tr></table></figure>
<p>这是我机器上的测试结果，A没有显示地址??怎么回事，两个实例都有自己的地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__main__.A &lt;__main__.A instance at 0x01262AD0&gt; &lt;__main__.A instance at 0x013091C0&gt;</span><br><span class="line">0 0 0</span><br><span class="line">0 10 0</span><br><span class="line">5 10 5</span><br><span class="line">5 10 10</span><br></pre></td></tr></table></figure>
<p>前两行的结果都很好理解，但是第三行，之前o2的值一直没有改变，o1的值改变，在A的值改变之后o2也随之改变了，这个时候….看上去，o2还是在引用A的值，但是在o2自己的值改变之后就不在去引用类的值了。</p>
<h5>由此可见：</h5>
<ul>
<li>
<p>由类派生出来的实例在未操作之前，都是简单的引用类的那些值</p>
</li>
<li>
<p>公共属性的值有点类似于大家C++类中的那种静态变量啊</p>
</li>
<li>
<p>只要实例稍作改变，就不会在引用类了。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python中得一些重要的细节]]></title>
      <url>http://kinglanding.github.io/2013/03/15/2013-03-15-some-important-details-in-python-personal/</url>
      <content type="html"><![CDATA[<p>字符串可以被下表索引，和C一样，第一个字符同样是0。</p>
<p>Python中并没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<p>和C字符串不同的是，python字符串值不能更改。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'string'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">3</span>]=<span class="string">'d'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>关于unicode的一些说明，encode(),unicode()那些往
<a href="http://docs.python.org/2/tutorial/introduction.html#unicode-strings" target="_blank" rel="external">这里看</a></p>
<p>python中一些iterable types（具体术语不知道怎么称呼）是分成可以<code>immutable</code>和<code>mutable</code>的：</p>
<h5>可更改的（<code>mutable</code>）:</h5>
<ul>
<li>
<p>字典型(dictionary)</p>
</li>
<li>
<p>列表型(list)</p>
</li>
</ul>
<h5>不可更改（mutable）：</h5>
<ul>
<li>
<p>元组（tuple)</p>
</li>
<li>
<p>数值型（number）</p>
</li>
<li>
<p>字符串(string)</p>
</li>
</ul>
<p>所有的切片操作都是返回一个新的包含请求元素的list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:]</span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="number">100</span>, <span class="number">1234</span>]</span><br></pre></td></tr></table></figure>
<p>pass语句请看<a href="http://docs.python.org/2/reference/simple_stmts.html#pass" target="_blank" rel="external">这里</a></p>
<p>函数中的变量，函数中得变量赋值操作都是把值存在<code>本地符号表（local symbol table）</code>中，
变量引用时先查看本地符号表，在然后是<code>全局符号表（global symbol table）</code>，
最后才是<code>内置表（table of built-in names）</code>，全局变量得先申明下，在使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v= <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_global_vars</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 测试使用global"""</span></span><br><span class="line">    <span class="comment">#global v += 1 #wrong!!</span></span><br><span class="line">    <span class="keyword">global</span> v </span><br><span class="line">    v += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> v</span><br></pre></td></tr></table></figure>
<p>突然想到了python中得变量类型这些东西，以下是实验</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_global_vars</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 测试使用global"""</span></span><br><span class="line">    <span class="keyword">global</span> v</span><br><span class="line">    v += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> v,hex(id(v))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""测试实参是怎么回事，by value，value总是个函数引用，不是那个</span><br><span class="line">    对象的值,实参也是跟函数内的变量一样被放入到了本地符号表"""</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> n,hex(id(n))</span><br><span class="line"> </span><br><span class="line">v= <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> v,hex(id(v))</span><br><span class="line">test_global_vars()</span><br><span class="line"><span class="keyword">print</span> v,hex(id(v))</span><br><span class="line">foo(v)</span><br><span class="line"><span class="keyword">print</span> v,hex(id(v))</span><br><span class="line">v+=<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> v,hex(id(v))</span><br></pre></td></tr></table></figure>
<p>这是我机器上的一次run result</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 0x1429168</span><br><span class="line">2 0x142915c</span><br><span class="line">2 0x142915c</span><br><span class="line">3 0x1429150</span><br><span class="line">2 0x142915c</span><br><span class="line">3 0x1429150</span><br></pre></td></tr></table></figure>
<p>会发现v的值一样的时候，id值都是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="number">1</span> 			<span class="comment">#将名字 v 与内存中值为1的内存绑定在一起。</span></span><br><span class="line">test_global_vars() 	<span class="comment">#这句话之后就是把v 和 内存中为2的地址绑定在一起。所以地址会变。</span></span><br><span class="line">foo(v) 			<span class="comment">#形参n 和 内存中为 3 的地址绑定在一起。实参v还是绑定在 2 的地址。</span></span><br><span class="line">v += <span class="number">1</span> 			<span class="comment">#v的值改变为3 所以地址就绑定到了 3 在内存中得地方。所以这个时候会发现和上一句的地址一样。</span></span><br></pre></td></tr></table></figure>
<p>很奇特，但是这个样子会有什么好处?</p>
<ul>
<li>
<p>首先python支持函数编程，函数式编程在运算的过程中值肯定是不会变得。
想想我们数学中得变量（怎么可能会出现x = x + 1 ！！）数学上讲不通。
这对函数式编程是个利好消息。（但是这很明显不是函数式编程，应该是这
个特性在lamda演算中很有用，待解决）</p>
</li>
<li>
<p>这个…受C、C++的“毒害”深啊，目前还是转不过来,但是在看列表<code>可变</code>之后
，刹那间觉得列表这玩意像指针那种东西啊</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">"value"</span>:<span class="number">3</span>&#125;</span><br><span class="line">b = dic</span><br><span class="line"><span class="keyword">print</span> dic,b,hex(id(dic)),hex(id(b))</span><br><span class="line">b[<span class="string">"value"</span>] = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> dic,b,hex(id(dic)),hex(id(b))</span><br></pre></td></tr></table></figure>
<p>但是你看结果，他们都是绑定到同一块内存的，这种字典的就直接在源地址改了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'value'</span>: <span class="number">3</span>&#125; &#123;<span class="string">'value'</span>: <span class="number">3</span>&#125; <span class="number">0x1823d20</span> <span class="number">0x1823d20</span></span><br><span class="line">&#123;<span class="string">'value'</span>: <span class="number">5</span>&#125; &#123;<span class="string">'value'</span>: <span class="number">5</span>&#125; <span class="number">0x1823d20</span> <span class="number">0x1823d20</span></span><br></pre></td></tr></table></figure>
<p>python就是这么设计的，至于为什么，不知道(待解决)</p>
<p>在说句题外话，你看django那些代码写的，都是使用的tuple之类的。url(省略号)…为什么会这个样子，来看看实验的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for A"""</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="comment"># self.x = [] #这个是错误的语法，只能在__init__中定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="comment">#x和self.value有什么区别啊</span></span><br><span class="line">        <span class="comment">#x和self.x有什么区别啊</span></span><br><span class="line">        super(A, self).__init__()</span><br><span class="line">        self.arg = arg</span><br><span class="line">        self.value = []</span><br><span class="line">        self.value.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in __init__"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"x address :\t\t\t\t"</span>, hex(id(x))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"self.x address :\t\t"</span>, hex(id(self.x))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x.append(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in get_x"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"x address :\t\t\t\t"</span>, hex(id(x))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"self.x address :\t\t"</span>, hex(id(self.x))</span><br><span class="line">        <span class="keyword">return</span> self.x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_xx</span><span class="params">(self)</span>:</span><span class="comment">#很诡异的存在啊，但这个只是定义的不同啊</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in get_xx"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"x address :\t\t\t\t"</span>, hex(id(x))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"self.x address :\t\t"</span>, hex(id(self.x))</span><br><span class="line">        <span class="keyword">return</span> x   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = A(<span class="string">"oj"</span>)</span><br><span class="line">    a.set_x()</span><br><span class="line">    <span class="comment">#print A.__dict__</span></span><br><span class="line">    <span class="keyword">print</span> a.get_value()</span><br><span class="line">    <span class="keyword">print</span> a.get_xx()</span><br><span class="line">    <span class="keyword">print</span> a.get_x()</span><br></pre></td></tr></table></figure>
<p>自己跑下试试，在__init__()内外定义的变量是不一样的，x，self.value类似static，全局共享。而self.x就不是了，在编码的时候一定要注意这种细节。</p>
<p>可能上面那个太复杂了些，那么看看这个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span>:</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y.append(<span class="number">1</span>)</span><br><span class="line">        self.x.append(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x,self.y,self.x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = b()</span><br><span class="line">    a.set()</span><br><span class="line">    <span class="keyword">print</span> a.get(),b.__dict__</span><br></pre></td></tr></table></figure>
<p>接下来还是关于函数的:</p>
<p>The default values are evaluated at the point of function definition in the defining scope, so that</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg=i)</span>:</span> <span class="comment"># 默认的初始值 只 赋值一次 ，其后初始就不会改变了。</span></span><br><span class="line">    <span class="keyword">print</span> arg</span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()           <span class="comment"># here will print  5！！ 所以这会为5 只要没传递新的参数</span></span><br></pre></td></tr></table></figure>
<p>但是当形参是个可变对象 如 :列表，字典或者一些类的实例，这个时候会共享这个可变的对象！！！</p>
<p>虽然元组（Tuples）和列表（list）看起来很相似，但是使用的场景不同的。元组通常是不可变的，
通常包括类型不同的元素，可以通过解包和索引来访问。列表是可变的，通常都是些同一类型的元素迭代访问。</p>
<p>遍历技巧，可能需要下标的时候会用到 <a href="http://docs.python.org/2/tutorial/datastructures.html#looping-techniques" target="_blank" rel="external">这里</a></p>
<hr>
<p>_xxx      不能用’from module import *’导入</p>
<p><strong>xxx</strong> 系统定义名字</p>
<p>__xxx    类中的私有变量名</p>
<p>以单下划线开头_foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；</p>
<p>以双下划线开头的__foo代表类的私有成员；以双下划线开头和结尾的__foo__代表python里特殊方法专用的标识，如__init__()代表类的构造函数。</p>
<p>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</p>
<p>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>
<p>######Python中的继承：</p>
<p>super可以避免显示的引用Base，这听起来很不错，最起码不用自己去判断使用哪个类的构造方法。
但是最最要的用途还是多继承问题。在python2.7中，得这样解决：super(thisClass,self).<strong>init</strong>() ,python3中变成了这样：super().<strong>init</strong>()</p>
<p>样例：仔细观察，不要忘记那个object！！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.x = x;</span><br><span class="line">		self.y = y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(Point)</span>:</span></span><br><span class="line">	<span class="string">"""docstring for Circle"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">		super(Circle,self).__init__()</span><br><span class="line">		<span class="comment"># Point.__init__(self,x,y)</span></span><br><span class="line">		self.radius = radius;</span><br><span class="line">c= Circle(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Base created"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildA</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(ChildB, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ChildA(),ChildB()</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git的安装和使用]]></title>
      <url>http://kinglanding.github.io/2011/03/14/2011-03-14-gitde-an-zhuang-he-shi-yong/</url>
      <content type="html"><![CDATA[<p>git之前一直使用的，但是n久没用居然忘记怎么使用了。。。中途使用过程中居然还出现了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>的错误，真是忘记怎么使用了，连SSH keys都没添加就想push啊…好吧，
真的是好记性不如烂笔头，老老实实的写下来已免在出这样的糗事</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git git-core</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>然后系统提示输入文件保存位置等信息，连续敲三次回车即可，生成的SSH key文件保存在中～/.ssh/id_rsa.publickey</p>
<p>接着拷贝.ssh/id_rsa.pub文件内的所以内容，将它粘帖到github帐号管理中的添加SSH key界面中。</p>
<h6>打开github帐号管理中的添加SSH key界面的步骤如下</h6>
<ul>
<li>
<p>登录github</p>
</li>
<li>
<p>点击右上方的Accounting settings图标</p>
</li>
<li>
<p>选择 SSH key</p>
</li>
<li>
<p>点击 Add SSH key</p>
</li>
</ul>
<p>在出现的界面中填写SSH key的名称，填一个你自己喜欢的名称即可，然后将上面拷贝的~/.ssh/id_rsa.pub文件内容粘帖到key一栏，
在点击“add key”按钮就可以了。添加过程github会提示你输入一次你的github密码。</p>
<h3>git 配置</h3>
<p>git有三个配置文件，分别是<code>repo/.git/config</code>,<code>$HOME/.gitconfig</code>,<code>/etc/gitconfig</code>.</p>
<ol>
<li>
<p>repo/.git/config 库级别的配置文件，只对当前库有效，优先级最高(git config –local)</p>
</li>
<li>
<p>$HOME/.gitconfig 用户级别的配置文件，对当前用户有效，优先级次之(git config –global)</p>
</li>
<li>
<p>/etc/gitconfig 系统全局配置文件，对整个系统有效，优先级最低(git config –system)</p>
</li>
</ol>
<p>git config –list 可以查看当前的git配置列表</p>
<p>如果已经配置了，则会看到user.name 和 user.email的配置信息</p>
<p>如果没有,一般情况下在git提交时会使用机器名，诸如：unknown dev@xxx-PC.(none) 等类型的Author信息，肯定不方便了。</p>
<p>建议都配置明确的user.name 和 user.email信息。</p>
<p>可以通过下面的命令进行配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name xxx</span><br><span class="line">git config user.email xxx@xxx.com</span><br></pre></td></tr></table></figure>
<p>配置完成后可以通过 git config –list 查看到.</p>
<p>这个准备工作算是完成了，其他的，就参考别人写得。在这不再写了。</p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li>
<p><a href="http://blog.sina.com.cn/s/blog_55465b470100s63h.html" target="_blank" rel="external">说明很详细</a></p>
</li>
<li>
<p><a href="http://simen-net.iteye.com/blog/832391" target="_blank" rel="external">这个有可能会用的着以后，搭建git server，在eclipse里集成git</a></p>
</li>
<li>
<p><a href="http://www.cnblogs.com/Jerry-Chou/archive/2012/05/14/2499088.html" target="_blank" rel="external">git常用命令</a></p>
</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
